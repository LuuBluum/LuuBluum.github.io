<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Brad Dragun (LuuBluum)"><meta name=description content="Having created the basic code structure for setting up a Vulkan project in Rust back in part 1, we can now actually deal with creating a Vulkan instance and setting up validation layers. All of the code can be found at this repo."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Learning Vulkan with Rust, Part 2: Creating a Vulkan Instance with Validation Layers"><meta name=twitter:description content="Having created the basic code structure for setting up a Vulkan project in Rust back in part 1, we can now actually deal with creating a Vulkan instance and setting up validation layers. All of the code can be found at this repo."><meta property="og:title" content="Learning Vulkan with Rust, Part 2: Creating a Vulkan Instance with Validation Layers"><meta property="og:description" content="Having created the basic code structure for setting up a Vulkan project in Rust back in part 1, we can now actually deal with creating a Vulkan instance and setting up validation layers. All of the code can be found at this repo."><meta property="og:type" content="article"><meta property="og:url" content="https://LuuBluum.github.io/posts/post2rustvulkan/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-31T14:45:18-07:00"><meta property="article:modified_time" content="2022-07-31T14:45:18-07:00"><title>LuuBluum's Coding Blog</title><link rel=canonical href=https://LuuBluum.github.io/posts/post2rustvulkan/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.102.3"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>LuuBluum's Coding Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://LuuBluum.github.io/posts/post2rustvulkan/>Learning Vulkan with Rust, Part 2: Creating a Vulkan Instance with Validation Layers</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-07-31T14:45:18-07:00>July 31, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
8-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/rust/>Rust</a>
<span class=separator>•</span>
<a href=/categories/vulkan/>Vulkan</a></div></div></header><div><p>Having created the basic code structure for setting up a Vulkan project in Rust back in <a href=https://luubluum.github.io/posts/post1rustvulkan/>part 1</a>, we can now actually deal with creating a <a href=https://vulkan-tutorial.com/en/Drawing_a_triangle/Setup/Instance>Vulkan instance</a> and setting up <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers>validation layers</a>. All of the code can be found at <a href=https://github.com/LuuBluum/Learning-Vulkan-with-Rust>this repo</a>.</p><p>Of course, since we&rsquo;re using Ash for this, the code won&rsquo;t necessarily be 1:1 with the equivalent in C++. Last time, we depopulated our app struct to just have a <code>new()</code> function and a <code>run()</code> function. For simplicity&rsquo;s sake we can go and restore the <code>init_window()</code> function, just using it during <code>new()</code> instead:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_window() -&gt; Result&lt;(winit::event_loop::EventLoop&lt;()&gt;, winit::window::Window), winit::error::OsError&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> event_loop = EventLoop::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> window = WindowBuilder::new()
</span></span><span style=display:flex><span>            .with_resizable(<span style=font-weight:700>false</span>)
</span></span><span style=display:flex><span>            .with_inner_size(PhysicalSize::new(WIDTH, HEIGHT))
</span></span><span style=display:flex><span>            .build(&amp;event_loop)?;
</span></span><span style=display:flex><span>        Ok((event_loop, window))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new() -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (event_loop, window) = HelloTriangleApplication::init_window().unwrap();
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            event_loop : <span style=font-weight:700>event_loop</span>,
</span></span><span style=display:flex><span>            window : <span style=font-weight:700>window</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now if we want to expand on our window functionality, it should be easier to do so. Plus, it gives us back a mechanism for handling errors. That leaves us with setting up Vulkan. We&rsquo;ll follow the same approach, with an <code>init_vulkan()</code> function that returns the desired instance:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan() -&gt; <span style=font-weight:700>prelude</span>::VkResult&lt;ash::Instance&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> entry = Entry::linked();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> app_info = vk::ApplicationInfo {
</span></span><span style=display:flex><span>            api_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> create_info = vk::InstanceCreateInfo {
</span></span><span style=display:flex><span>            p_application_info: <span>&amp;</span><span style=font-weight:700>app_info</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { entry.create_instance(&amp;create_info, None) }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Notably here we needed to break out <code>unsafe</code>, since everything handled in Ash is unsafe. Additionally, we didn&rsquo;t need to deal with the window at all for setting up Vulkan. As for cleanup, for this we will need to implement Drop. Certainly better than explicitly needing to invoke a cleanup function which we can&rsquo;t otherwise explicitly invoke anyway. So, we can quickly implement that:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>impl</span> Drop <span style=font-weight:700>for</span> HelloTriangleApplication {
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> drop(&amp;<span style=font-weight:700>mut</span> self)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And everything should be fine. Right?</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>error[E0509]: cannot move <span style=font-weight:700>out</span> of type `HelloTriangleApplication`, which implements the `<span style=font-weight:700>Drop</span>` trait
</span></span><span style=display:flex><span>  --&gt; src<span>\</span>instance.rs:49:9
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>49 |         self.event_loop.run(move |event, _, control_flow| <span>{</span>
</span></span><span style=display:flex><span>   |         ^^^^^^^^^^^^^^^
</span></span><span style=display:flex><span>   |         |
</span></span><span style=display:flex><span>   |         cannot move <span style=font-weight:700>out</span> of here
</span></span><span style=display:flex><span>   |         move occurs because `self.event_loop` has type `EventLoop&lt;()&gt;`, which does <span style=font-weight:700>not</span> implement the `Copy` trait
</span></span></code></pre></div><p>Well, no. The issue here is that this actually moves <code>event_loop</code> out of our application. We have <code>Drop</code> implemented, meaning we want things to be&mldr; well, sane. This explicitly makes things not sane. This whole structure here is a bit of a pickle: we&rsquo;re partially moving <code>self</code> (specifically our event loop) over to this new thread, but not the rest of it. This is a problem. What we need to do is move the rest of <code>self</code> into this loop. We can do that fairly easily, with <code>let Self { .. } = self;</code> within. However, there&rsquo;s another problem: we can&rsquo;t actually do that because we already partially moved <code>self</code> into the loop to begin with.</p><p>What we need to do is decouple <code>event_loop</code> from <code>self</code> entirely. Fortunately we just created an <code>init_window()</code> function which trivializes this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>HelloTriangleApplication</span> {
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> HelloTriangleApplication {
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_window() -&gt; Result&lt;(winit::event_loop::EventLoop&lt;()&gt;, winit::window::Window), winit::error::OsError&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> event_loop = EventLoop::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> window = WindowBuilder::new()
</span></span><span style=display:flex><span>            .with_resizable(<span style=font-weight:700>false</span>)
</span></span><span style=display:flex><span>            .with_inner_size(PhysicalSize::new(WIDTH, HEIGHT))
</span></span><span style=display:flex><span>            .build(&amp;event_loop)?;
</span></span><span style=display:flex><span>        Ok((event_loop, window))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan() -&gt; <span style=font-weight:700>prelude</span>::VkResult&lt;ash::Instance&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> entry = Entry::linked();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> app_info = vk::ApplicationInfo {
</span></span><span style=display:flex><span>            api_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> create_info = vk::InstanceCreateInfo {
</span></span><span style=display:flex><span>            p_application_info: <span>&amp;</span><span style=font-weight:700>app_info</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { entry.create_instance(&amp;create_info, None) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new() -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> instance = HelloTriangleApplication::init_vulkan().unwrap();
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            instance: <span style=font-weight:700>instance</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(&amp;self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (event_loop, window) = HelloTriangleApplication::init_window().unwrap();
</span></span><span style=display:flex><span>        event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Wait;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == window.id() =&gt; *control_flow = ControlFlow::Exit,
</span></span><span style=display:flex><span>                _ =&gt; (),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> Drop <span style=font-weight:700>for</span> HelloTriangleApplication {
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> drop(&amp;<span style=font-weight:700>mut</span> self)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that, we can move on to validation layers.</p><h2 id=validation-layers>Validation Layers
<a class=heading-link href=#validation-layers><i class="fa fa-link" aria-hidden=true></i></a></h2><p>So, starting off with where we were before, our next goal is to make sure that things aren&rsquo;t actually breaking. They seem fine given that we do create a window, but that doesn&rsquo;t mean anything. As with the tutorial, we&rsquo;ll create a constant vector of strings for our layers, though we won&rsquo;t bother with the debug build options:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>const</span> VALIDATION_LAYERS : <span>&amp;</span>[*<span style=font-weight:700>const</span> <span>i8</span>] = &amp;[
</span></span><span style=display:flex><span>    <span style=font-weight:700>unsafe</span> { CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;VK_LAYER_KHRONOS_validation\0&#34;</span>.as_bytes()).as_ptr() }
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>It&rsquo;s hideous because Vulkan wants C strings. That&rsquo;s how you get C strings in Rust. Now, we want to implement checking of validation layers. Notably, this actually requires an instantiated entry, so we insert this as a call unassociated with our overall app directly into our <code>init_vulkan()</code> function, taking the entry as an argument:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> check_validation_layer_support(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry) -&gt; <span>bool</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> layer_properties = entry.enumerate_instance_layer_properties().unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> layer <span style=font-weight:700>in</span> VALIDATION_LAYERS {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> <span style=font-weight:700>let</span> None = layer_properties.iter().find(|l| {
</span></span><span style=display:flex><span>                <span style=font-style:italic>// This horrible construction is because Vulkan operates with C strings and Rust does not
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>               <span style=font-weight:700>unsafe</span> { &amp;CStr::from_ptr(l.layer_name.as_ptr()).to_str().unwrap() == &amp;CStr::from_ptr(*layer).to_str().unwrap() }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Just, uh, ignore that unsafe block.</p><p>With that done, we can now start worrying about required extensions. This is actually a bit of a problem: the tutorial expects glfw to handle all of this for us. We don&rsquo;t have that luxury in Rust; we need to know what extensions are relevant on what platforms. Given that I&rsquo;m running on Windows, I&rsquo;ll just stick with that for the sake of this tutorial. More broadly-handled multiplatform stuff is a bit beyond scope here. So, we&rsquo;ll create another array:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::khr::Win32Surface;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::khr::Surface;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::ext::DebugUtils;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> REQUIRED_EXTENSIONS : <span>&amp;</span>[*<span style=font-weight:700>const</span> <span>i8</span>] = &amp;[
</span></span><span style=display:flex><span>    Surface::name().as_ptr(),
</span></span><span style=display:flex><span>    Win32Surface::name().as_ptr(),
</span></span><span style=display:flex><span>    DebugUtils::name().as_ptr(),
</span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>Now we can integrate these required extensions into our creating of an instance:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan() -&gt; <span style=font-weight:700>prelude</span>::VkResult&lt;ash::Instance&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> entry = Entry::linked();
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> !check_validation_layer_support(&amp;entry)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            panic!(<span style=font-style:italic>&#34;Could not find support for all layers!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> app_info = vk::ApplicationInfo {
</span></span><span style=display:flex><span>            api_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> create_info = vk::InstanceCreateInfo {
</span></span><span style=display:flex><span>            p_application_info: <span>&amp;</span><span style=font-weight:700>app_info</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        create_info.enabled_extension_count = REQUIRED_EXTENSIONS.len() <span style=font-weight:700>as</span> <span>u32</span>;
</span></span><span style=display:flex><span>        create_info.pp_enabled_extension_names = REQUIRED_EXTENSIONS.as_ptr();
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { entry.create_instance(&amp;create_info, None) }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Everything runs, there&rsquo;s no issues, and surely this isn&rsquo;t a house of cards balanced precariously over a burning oil drum. With that, we can move on to constructing a callback function. We can start with the basic skeleton:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>extern</span> <span style=font-style:italic>&#34;system&#34;</span> <span style=font-weight:700>fn</span> debug_callback(
</span></span><span style=display:flex><span>    message_severity: <span style=font-weight:700>vk</span>::DebugUtilsMessageSeverityFlagsEXT,
</span></span><span style=display:flex><span>    message_type: <span style=font-weight:700>vk</span>::DebugUtilsMessageTypeFlagsEXT,
</span></span><span style=display:flex><span>    callback_data: *<span style=font-weight:700>const</span> vk::DebugUtilsMessengerCallbackDataEXT,
</span></span><span style=display:flex><span>    _: *<span style=font-weight:700>mut</span> c_void,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::Bool32 {
</span></span><span style=display:flex><span>        print!(<span style=font-style:italic>&#34;validation layer: {}&#34;</span>, <span style=font-weight:700>unsafe</span> { CStr::from_ptr((*callback_data).p_message).to_str().unwrap() });
</span></span><span style=display:flex><span>        vk::FALSE
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Note that this is declared <code>extern "system"</code> so that Vulkan can use it as a callback. The structure is otherwise identical as the equivalent in C++, other than we explicitly ignore the user data because that&rsquo;s not useful for our purposes and any sane not-bare-metal Vulkan API would bury such a thing anyway. As is the running theme here, there is yet another <code>unsafe</code> block to deal with a C string, though this one also serves double-duty in dereferencing our callback data pointer. Naturally, we need to bake this callback directly into our overall struct:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>HelloTriangleApplication</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Fortunately for us, ash already provides the function we want to construct our messenger, so we merely need to call it, with some fiddling to make sure that we have access to everything we need:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry) -&gt; <span style=font-weight:700>prelude</span>::VkResult&lt;ash::Instance&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> !HelloTriangleApplication::check_validation_layer_support(&amp;entry)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            panic!(<span style=font-style:italic>&#34;Could not find support for all layers!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> app_info = vk::ApplicationInfo {
</span></span><span style=display:flex><span>            api_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> create_info = vk::InstanceCreateInfo {
</span></span><span style=display:flex><span>            p_application_info: <span>&amp;</span><span style=font-weight:700>app_info</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        create_info.enabled_extension_count = REQUIRED_EXTENSIONS.len() <span style=font-weight:700>as</span> <span>u32</span>;
</span></span><span style=display:flex><span>        create_info.pp_enabled_extension_names = REQUIRED_EXTENSIONS.as_ptr();
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { entry.create_instance(&amp;create_info, None) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> setup_debug_messenger() -&gt; <span style=font-weight:700>vk</span>::DebugUtilsMessengerCreateInfoEXT {
</span></span><span style=display:flex><span>        vk::DebugUtilsMessengerCreateInfoEXT {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
</span></span><span style=display:flex><span>            message_severity: <span style=font-weight:700>vk</span>::DebugUtilsMessageSeverityFlagsEXT::VERBOSE | vk::DebugUtilsMessageSeverityFlagsEXT::WARNING | vk::DebugUtilsMessageSeverityFlagsEXT::ERROR,
</span></span><span style=display:flex><span>            message_type: <span style=font-weight:700>vk</span>::DebugUtilsMessageTypeFlagsEXT::GENERAL | vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION | vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
</span></span><span style=display:flex><span>            pfn_user_callback: Some(debug_callback),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new() -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> entry = Entry::linked();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> instance = HelloTriangleApplication::init_vulkan(&amp;entry).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> debug_messenger = <span style=font-weight:700>unsafe</span> { DebugUtils::new(&amp;entry, &amp;instance).create_debug_utils_messenger(&amp;HelloTriangleApplication::setup_debug_messenger(), None).unwrap() };
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            entry: <span style=font-weight:700>entry</span>,
</span></span><span style=display:flex><span>            instance: <span style=font-weight:700>instance</span>,
</span></span><span style=display:flex><span>            debug_messenger: <span style=font-weight:700>debug_messenger</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And then we add it to our <code>Drop</code> implementation:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>impl</span> Drop <span style=font-weight:700>for</span> HelloTriangleApplication {
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> drop(&amp;<span style=font-weight:700>mut</span> self)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance).destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, for setting up our debug messenger to play nicely with creating an instance, we have to create two messengers, in a sense. One is as we already create, and the other attaches itself to our instance:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry) -&gt; <span style=font-weight:700>prelude</span>::VkResult&lt;ash::Instance&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> !HelloTriangleApplication::check_validation_layer_support(&amp;entry)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            panic!(<span style=font-style:italic>&#34;Could not find support for all layers!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> app_info = vk::ApplicationInfo {
</span></span><span style=display:flex><span>            api_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> create_info = vk::InstanceCreateInfo {
</span></span><span style=display:flex><span>            p_application_info: <span>&amp;</span><span style=font-weight:700>app_info</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        create_info.enabled_layer_count = VALIDATION_LAYERS.len() <span style=font-weight:700>as</span> <span>u32</span>;
</span></span><span style=display:flex><span>        create_info.pp_enabled_layer_names = VALIDATION_LAYERS.as_ptr();
</span></span><span style=display:flex><span>        create_info.enabled_extension_count = REQUIRED_EXTENSIONS.len() <span style=font-weight:700>as</span> <span>u32</span>;
</span></span><span style=display:flex><span>        create_info.pp_enabled_extension_names = REQUIRED_EXTENSIONS.as_ptr();
</span></span><span style=display:flex><span>        create_info.p_next = &amp;HelloTriangleApplication::setup_debug_messenger() <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> _ <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> c_void;
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { entry.create_instance(&amp;create_info, None) }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>(don&rsquo;t question that cast)</p><p>Now, if we test this, we&rsquo;ll see all the validation layers working properly&mldr; except <code>Drop</code> isn&rsquo;t being called. As it turns out, using <code>Drop</code> here is a problem: the event loop hijacks the main thread and keeps anything not brought in from dropping. So, the better approach here is a cleanup function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance).destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(<span style=font-weight:700>mut</span> self) -&gt; ! {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (event_loop, window) = HelloTriangleApplication::init_window().unwrap();
</span></span><span style=display:flex><span>        event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Wait;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == window.id() =&gt; {
</span></span><span style=display:flex><span>                    self.cleanup();
</span></span><span style=display:flex><span>                    *control_flow = ControlFlow::Exit
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                _ =&gt; (),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>With that, not only are we configuring our Vulkan setup, but we&rsquo;re even setting up validation layers to keep up with any sort of errors we make along the way! For which there will be plenty! Next time, we&rsquo;ll start tackling fetching details on physical devices and possibly logical devices as well!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2022
Brad Dragun (LuuBluum)
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script></body></html>