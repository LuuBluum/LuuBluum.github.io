<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Brad Dragun (LuuBluum)"><meta name=description content="Now that we have vertex buffers all set up, there remains one glaring flaw in our approach. Namely, we&rsquo;re still limited to 2D. What about 3D? For that, we need to implement uniform buffers and start being able to handle global variables in the Rust side of things.. All of the code can be found at this repo."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Learning Vulkan with Rust, Part 9: Uniform Buffers"><meta name=twitter:description content="Now that we have vertex buffers all set up, there remains one glaring flaw in our approach. Namely, we&rsquo;re still limited to 2D. What about 3D? For that, we need to implement uniform buffers and start being able to handle global variables in the Rust side of things.. All of the code can be found at this repo."><meta property="og:title" content="Learning Vulkan with Rust, Part 9: Uniform Buffers"><meta property="og:description" content="Now that we have vertex buffers all set up, there remains one glaring flaw in our approach. Namely, we&rsquo;re still limited to 2D. What about 3D? For that, we need to implement uniform buffers and start being able to handle global variables in the Rust side of things.. All of the code can be found at this repo."><meta property="og:type" content="article"><meta property="og:url" content="https://LuuBluum.github.io/posts/post9rustvulkan/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-12T12:32:40-07:00"><meta property="article:modified_time" content="2022-09-12T12:32:40-07:00"><title>LuuBluum's Coding Blog</title><link rel=canonical href=https://LuuBluum.github.io/posts/post9rustvulkan/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.102.3"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>LuuBluum's Coding Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://LuuBluum.github.io/posts/post9rustvulkan/>Learning Vulkan with Rust, Part 9: Uniform Buffers</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-09-12T12:32:40-07:00>September 12, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
5-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/rust/>Rust</a>
<span class=separator>â€¢</span>
<a href=/categories/vulkan/>Vulkan</a></div></div></header><div><p>Now that we have <a href=https://vulkan-tutorial.com/Vertex_buffers/Vertex_input_description>vertex buffers</a> all set up, there remains one glaring flaw in our approach. Namely, we&rsquo;re still limited to 2D. What about 3D? For that, we need to implement <a href=https://vulkan-tutorial.com/Uniform_buffers/Descriptor_layout_and_buffer>uniform buffers</a> and start being able to handle global variables in the Rust side of things.. All of the code can be found at <a href=https://github.com/LuuBluum/Learning-Vulkan-with-Rust>this repo</a>.</p><p>Starting off, we&rsquo;re going to need to make more use of our linear algebra details. Namely, we&rsquo;re going to need a model-view-projection matrix. First, we&rsquo;re going to update our shaders as specified in the tutorial:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span>#version 450
</span></span></span><span style=display:flex><span><span></span>
</span></span><span style=display:flex><span>layout(binding = 0) uniform UniformBufferObject {
</span></span><span style=display:flex><span>    mat4 model;
</span></span><span style=display:flex><span>    mat4 view;
</span></span><span style=display:flex><span>    mat4 proj;
</span></span><span style=display:flex><span>} ubo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>layout(location = 0) in vec2 inPosition;
</span></span><span style=display:flex><span>layout(location = 1) in vec3 inColor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>layout(location = 0) out vec3 fragColor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span>void</span> main() {
</span></span><span style=display:flex><span>    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0);
</span></span><span style=display:flex><span>    fragColor = inColor;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This gives us what we want, at least in the shader side of things. After recompiling our shader, we go back to working on the Rust side of things. First, we need to have this representation in our Rust code:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span>#[repr(C)]</span>
</span></span><span style=display:flex><span><span style=font-weight:700>struct</span> <span style=font-weight:700>UniformBufferObject</span> {
</span></span><span style=display:flex><span>    model: <span style=font-weight:700>glam</span>::Mat4,
</span></span><span style=display:flex><span>    view: <span style=font-weight:700>glam</span>::Mat4,
</span></span><span style=display:flex><span>    proj: <span style=font-weight:700>glam</span>::Mat4,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We structure it as it would for C because this is going to be sent over to our shader and we want the formatting to match. We have our model, view, and projection matrices contained within. Now we&rsquo;re going to need a new function for initializing our descriptor set layout:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_descriptor_set_layout(device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device) -&gt; <span style=font-weight:700>vk</span>::DescriptorSetLayout {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> ubo_layout_binding = vk::DescriptorSetLayoutBinding {
</span></span><span style=display:flex><span>            binding: 0,
</span></span><span style=display:flex><span>            descriptor_type: <span style=font-weight:700>vk</span>::DescriptorType::UNIFORM_BUFFER,
</span></span><span style=display:flex><span>            descriptor_count: 1,
</span></span><span style=display:flex><span>            stage_flags: <span style=font-weight:700>vk</span>::ShaderStageFlags::VERTEX,
</span></span><span style=display:flex><span>            p_immutable_samplers: <span style=font-weight:700>ptr</span>::null(),
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> layout_info = vk::DescriptorSetLayoutCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
</span></span><span style=display:flex><span>            binding_count: 1,
</span></span><span style=display:flex><span>            p_bindings: <span>&amp;</span><span style=font-weight:700>ubo_layout_binding</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            device
</span></span><span style=display:flex><span>                .create_descriptor_set_layout(&amp;layout_info, None)
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Nothing particularly revolutionary. We create the necessary binding details (it&rsquo;s a uniform buffer with one descriptor in our vetex stage without any immutable samplers), feed that into our create info, and then create. This is now used in our pipeline:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> pipeline_layout_info = vk::PipelineLayoutCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_LAYOUT_CREATE_INFO,
</span></span><span style=display:flex><span>            set_layout_count: 1,
</span></span><span style=display:flex><span>            p_set_layouts: <span style=font-weight:700>layout</span>,
</span></span><span style=display:flex><span>            push_constant_range_count: 0,
</span></span><span style=display:flex><span>            p_push_constant_ranges: <span style=font-weight:700>ptr</span>::null(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>Throw it into our cleanup function and we&rsquo;re done with that. Now we need to actually create the layouts. More values in our Vulkan details struct! Another creation function to implement!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_uniform_buffers(
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        physical_device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    ) -&gt; (Vec&lt;vk::Buffer&gt;, Vec&lt;vk::DeviceMemory&gt;) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> buffer_size = std::mem::size_of::&lt;UniformBufferObject&gt;() <span style=font-weight:700>as</span> vk::DeviceSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> uniform_buffers = Vec::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> uniform_buffers_memory = Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        uniform_buffers.reserve(MAX_FRAMES_IN_FLIGHT);
</span></span><span style=display:flex><span>        uniform_buffers_memory.reserve(MAX_FRAMES_IN_FLIGHT);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> _ <span style=font-weight:700>in</span> 0..MAX_FRAMES_IN_FLIGHT {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> (uniform_buffer, uniform_buffer_memory) = VulkanDetails::create_buffer(
</span></span><span style=display:flex><span>                instance,
</span></span><span style=display:flex><span>                physical_device,
</span></span><span style=display:flex><span>                device,
</span></span><span style=display:flex><span>                buffer_size,
</span></span><span style=display:flex><span>                vk::BufferUsageFlags::UNIFORM_BUFFER,
</span></span><span style=display:flex><span>                vk::MemoryPropertyFlags::HOST_VISIBLE | vk::MemoryPropertyFlags::HOST_COHERENT,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            uniform_buffers.push(uniform_buffer);
</span></span><span style=display:flex><span>            uniform_buffers_memory.push(uniform_buffer_memory);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        (uniform_buffers, uniform_buffers_memory)
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>With that out of the way, now we need to actually update our uniform buffer during drawing. Otherwise all of this will have been pointless, for our uniform buffer would be static. The update function is&mldr; well, it&rsquo;s just the math explained in the tutorial, really, with adding the start time as a set-once internal variable initialized to the unix epoch so that we set it once on the first call and never set it again:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_uniform_buffers(
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        physical_device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    ) -&gt; (Vec&lt;vk::Buffer&gt;, Vec&lt;vk::DeviceMemory&gt;) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> buffer_size = std::mem::size_of::&lt;UniformBufferObject&gt;() <span style=font-weight:700>as</span> vk::DeviceSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> uniform_buffers = Vec::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> uniform_buffers_memory = Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        uniform_buffers.reserve(MAX_FRAMES_IN_FLIGHT);
</span></span><span style=display:flex><span>        uniform_buffers_memory.reserve(MAX_FRAMES_IN_FLIGHT);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> _ <span style=font-weight:700>in</span> 0..MAX_FRAMES_IN_FLIGHT {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> (uniform_buffer, uniform_buffer_memory) = VulkanDetails::create_buffer(
</span></span><span style=display:flex><span>                instance,
</span></span><span style=display:flex><span>                physical_device,
</span></span><span style=display:flex><span>                device,
</span></span><span style=display:flex><span>                buffer_size,
</span></span><span style=display:flex><span>                vk::BufferUsageFlags::UNIFORM_BUFFER,
</span></span><span style=display:flex><span>                vk::MemoryPropertyFlags::HOST_VISIBLE | vk::MemoryPropertyFlags::HOST_COHERENT,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            uniform_buffers.push(uniform_buffer);
</span></span><span style=display:flex><span>            uniform_buffers_memory.push(uniform_buffer_memory);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        (uniform_buffers, uniform_buffers_memory)
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>All of this should work, right?</p><p>Well, no. Running it now and we get a ton of errors vomited at us from the validation layers and nothing draws. Not great. Seems to be complaining about a lack of descriptor sets&mldr;</p><h2 id=the-descriptor-pool>The Descriptor Pool
<a class=heading-link href=#the-descriptor-pool><i class="fa fa-link" aria-hidden=true></i></a></h2><p>So, it seems we need to push into <a href=https://vulkan-tutorial.com/en/Uniform_buffers/Descriptor_pool_and_sets>descriptor pools and descriptor sets</a> before we get this to actually function. So, on we proceed. Now we need to configure our descriptor pool, starting with its creation:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_descriptor_pool(device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device) -&gt; <span style=font-weight:700>vk</span>::DescriptorPool {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> pool_size = vk::DescriptorPoolSize {
</span></span><span style=display:flex><span>            ty: <span style=font-weight:700>vk</span>::DescriptorType::UNIFORM_BUFFER,
</span></span><span style=display:flex><span>            descriptor_count: <span style=font-weight:700>MAX_FRAMES_IN_FLIGHT</span> <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> pool_info = vk::DescriptorPoolCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DESCRIPTOR_POOL_CREATE_INFO,
</span></span><span style=display:flex><span>            pool_size_count: 1,
</span></span><span style=display:flex><span>            p_pool_sizes: <span>&amp;</span><span style=font-weight:700>pool_size</span>,
</span></span><span style=display:flex><span>            max_sets: <span style=font-weight:700>MAX_FRAMES_IN_FLIGHT</span> <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { device.create_descriptor_pool(&amp;pool_info, None).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Nothing special about this. The allocation function for our descriptor sets is not much fancier:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_descriptor_sets(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        descriptor_set_layout: <span>&amp;</span><span style=font-weight:700>vk</span>::DescriptorSetLayout,
</span></span><span style=display:flex><span>        descriptor_pool: <span>&amp;</span><span style=font-weight:700>vk</span>::DescriptorPool,
</span></span><span style=display:flex><span>    ) -&gt; Vec&lt;vk::DescriptorSet&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> layouts = vec![*descriptor_set_layout; MAX_FRAMES_IN_FLIGHT];
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> alloc_info = vk::DescriptorSetAllocateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DESCRIPTOR_SET_ALLOCATE_INFO,
</span></span><span style=display:flex><span>            descriptor_pool: *descriptor_pool,
</span></span><span style=display:flex><span>            descriptor_set_count: <span style=font-weight:700>MAX_FRAMES_IN_FLIGHT</span> <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            p_set_layouts: <span style=font-weight:700>layouts</span>.as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { device.allocate_descriptor_sets(&amp;alloc_info).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>We clean up the pool right before the descriptor set layout. However, this only allocates our descriptor sets. They&rsquo;re still unpopulated! Let&rsquo;s fix that:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_descriptor_sets(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        uniform_buffers: <span>&amp;</span>Vec&lt;vk::Buffer&gt;,
</span></span><span style=display:flex><span>        descriptor_set_layout: <span>&amp;</span><span style=font-weight:700>vk</span>::DescriptorSetLayout,
</span></span><span style=display:flex><span>        descriptor_pool: <span>&amp;</span><span style=font-weight:700>vk</span>::DescriptorPool,
</span></span><span style=display:flex><span>    ) -&gt; Vec&lt;vk::DescriptorSet&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> layouts = vec![*descriptor_set_layout; MAX_FRAMES_IN_FLIGHT];
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> alloc_info = vk::DescriptorSetAllocateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
</span></span><span style=display:flex><span>            descriptor_pool: *descriptor_pool,
</span></span><span style=display:flex><span>            descriptor_set_count: <span style=font-weight:700>MAX_FRAMES_IN_FLIGHT</span> <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            p_set_layouts: <span style=font-weight:700>layouts</span>.as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> descriptor_sets = <span style=font-weight:700>unsafe</span> { device.allocate_descriptor_sets(&amp;alloc_info).unwrap() };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> i <span style=font-weight:700>in</span> 0..MAX_FRAMES_IN_FLIGHT {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> buffer_info = vk::DescriptorBufferInfo {
</span></span><span style=display:flex><span>                buffer: <span style=font-weight:700>uniform_buffers</span>[i],
</span></span><span style=display:flex><span>                offset: 0,
</span></span><span style=display:flex><span>                range: <span style=font-weight:700>size_of</span>::&lt;UniformBufferObject&gt;() <span style=font-weight:700>as</span> <span>u64</span>,
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> descriptor_write = vk::WriteDescriptorSet {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::WRITE_DESCRIPTOR_SET,
</span></span><span style=display:flex><span>                dst_set: <span style=font-weight:700>descriptor_sets</span>[i],
</span></span><span style=display:flex><span>                dst_binding: 0,
</span></span><span style=display:flex><span>                dst_array_element: 0,
</span></span><span style=display:flex><span>                descriptor_type: <span style=font-weight:700>vk</span>::DescriptorType::UNIFORM_BUFFER,
</span></span><span style=display:flex><span>                descriptor_count: 1,
</span></span><span style=display:flex><span>                p_buffer_info: <span>&amp;</span><span style=font-weight:700>buffer_info</span>,
</span></span><span style=display:flex><span>                p_image_info: <span style=font-weight:700>ptr</span>::null(),
</span></span><span style=display:flex><span>                p_texel_buffer_view: <span style=font-weight:700>ptr</span>::null(),
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                device.update_descriptor_sets(
</span></span><span style=display:flex><span>                    [descriptor_write].as_ref(),
</span></span><span style=display:flex><span>                    &amp;[] <span style=font-weight:700>as</span> &amp;[vk::CopyDescriptorSet],
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        descriptor_sets
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now we just need to update our command buffer details:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>            self.device.cmd_bind_descriptor_sets(
</span></span><span style=display:flex><span>                self.command_buffers[self.current_frame],
</span></span><span style=display:flex><span>                vk::PipelineBindPoint::GRAPHICS,
</span></span><span style=display:flex><span>                self.pipeline_layout,
</span></span><span style=display:flex><span>                0,
</span></span><span style=display:flex><span>                [self.descriptor_sets[self.current_frame]].as_ref(),
</span></span><span style=display:flex><span>                &amp;[],
</span></span><span style=display:flex><span>            );
</span></span></code></pre></div><p>Throw that in there right above the draw command and update the rasterizer details and&mldr; we&rsquo;re drawing it upside-down! Whoops! Seems the GL constraints apply to this, too. Go back and multiply our projection matrix&rsquo;s y value by -1. Curiously enough we need to set the rasterizer back to clockwise. Now we have a spinning triangle! Or rather, rectangle, due to some details that we changed about aspect ratio. Regardless, it works! It spins! It&rsquo;s not baked into the shader!</p><p>Think of how far we&rsquo;ve come with all of this!</p></div><footer></footer></article></section></div><footer class=footer><section class=container>Â©
2022
Brad Dragun (LuuBluum)
Â·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script></body></html>