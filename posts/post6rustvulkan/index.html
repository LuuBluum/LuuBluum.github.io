<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Brad Dragun (LuuBluum)"><meta name=description content="Now that we have the swapchain and image views set up, we can finally start work on something a bit more broadly relevant: the graphics pipeline. All of the code can be found at this repo."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Learning Vulkan with Rust, Part 6: The Graphics Pipeline"><meta name=twitter:description content="Now that we have the swapchain and image views set up, we can finally start work on something a bit more broadly relevant: the graphics pipeline. All of the code can be found at this repo."><meta property="og:title" content="Learning Vulkan with Rust, Part 6: The Graphics Pipeline"><meta property="og:description" content="Now that we have the swapchain and image views set up, we can finally start work on something a bit more broadly relevant: the graphics pipeline. All of the code can be found at this repo."><meta property="og:type" content="article"><meta property="og:url" content="https://LuuBluum.github.io/posts/post6rustvulkan/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-13T12:32:47-07:00"><meta property="article:modified_time" content="2022-08-13T12:32:47-07:00"><title>LuuBluum's Coding Blog</title><link rel=canonical href=https://LuuBluum.github.io/posts/post6rustvulkan/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>LuuBluum's Coding Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://LuuBluum.github.io/posts/post6rustvulkan/>Learning Vulkan with Rust, Part 6: The Graphics Pipeline</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-08-13T12:32:47-07:00>August 13, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
8-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/rust/>Rust</a>
<span class=separator>â€¢</span>
<a href=/categories/vulkan/>Vulkan</a></div></div></header><div><p>Now that we have <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain>the swapchain</a> and <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Image_views>image views</a> set up, we can finally start work on something a bit more broadly relevant: the <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction>graphics pipeline</a>. All of the code can be found at <a href=https://github.com/LuuBluum/Learning-Vulkan-with-Rust>this repo</a>.</p><p>This will be our first venturing into the actual process of drawing something with Vulkan. How exciting! Of course this means there&rsquo;s a good chunk of this that isn&rsquo;t on Rust at all; I&rsquo;ll leave the GLSL discussion to the Vulkan tutorial, because nothing will change there.</p><p>In the meantime, let&rsquo;s set up our configuration so we can do things properly:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan(
</span></span><span style=display:flex><span>        window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window,
</span></span><span style=display:flex><span>    ) -&gt; (
</span></span><span style=display:flex><span>        ash::Entry,
</span></span><span style=display:flex><span>        ash::Instance,
</span></span><span style=display:flex><span>        vk::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>        vk::SurfaceKHR,
</span></span><span style=display:flex><span>        vk::PhysicalDevice,
</span></span><span style=display:flex><span>        ash::Device,
</span></span><span style=display:flex><span>        vk::Queue,
</span></span><span style=display:flex><span>        vk::Queue,
</span></span><span style=display:flex><span>        vk::SwapchainKHR,
</span></span><span style=display:flex><span>        Vec&lt;vk::Image&gt;,
</span></span><span style=display:flex><span>        vk::Format,
</span></span><span style=display:flex><span>        vk::Extent2D,
</span></span><span style=display:flex><span>        Vec&lt;vk::ImageView&gt;,
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> entry = Entry::linked();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> instance = VulkanDetails::create_instance(&amp;entry).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> debug_messenger = VulkanDetails::create_debug_messenger(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface = VulkanDetails::create_surface(&amp;window, &amp;entry, &amp;instance).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> physical_device =
</span></span><span style=display:flex><span>            VulkanDetails::pick_physical_device(&amp;entry, &amp;instance, &amp;surface).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device =
</span></span><span style=display:flex><span>            VulkanDetails::create_logical_device(&amp;entry, &amp;instance, &amp;physical_device, &amp;surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_index, present_queue_index) =
</span></span><span style=display:flex><span>            VulkanDetails::find_queue_familes(&amp;entry, &amp;instance, &amp;physical_device, &amp;surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> graphics_queue =
</span></span><span style=display:flex><span>            <span style=font-weight:700>unsafe</span> { device.get_device_queue(graphics_queue_index.unwrap() <span style=font-weight:700>as</span> <span>u32</span>, 0) };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> present_queue =
</span></span><span style=display:flex><span>            <span style=font-weight:700>unsafe</span> { device.get_device_queue(present_queue_index.unwrap() <span style=font-weight:700>as</span> <span>u32</span>, 0) };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (swap_chain, swap_chain_images, swap_chain_image_format, swap_chain_extent) =
</span></span><span style=display:flex><span>            VulkanDetails::create_swap_chain(
</span></span><span style=display:flex><span>                window,
</span></span><span style=display:flex><span>                &amp;entry,
</span></span><span style=display:flex><span>                &amp;instance,
</span></span><span style=display:flex><span>                &amp;physical_device,
</span></span><span style=display:flex><span>                &amp;device,
</span></span><span style=display:flex><span>                &amp;surface,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> image_views = VulkanDetails::create_image_views(
</span></span><span style=display:flex><span>            &amp;device,
</span></span><span style=display:flex><span>            &amp;swap_chain_images,
</span></span><span style=display:flex><span>            &amp;swap_chain_image_format,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        VulkanDetails::create_graphics_pipeline();
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            entry,
</span></span><span style=display:flex><span>            instance,
</span></span><span style=display:flex><span>            debug_messenger,
</span></span><span style=display:flex><span>            surface,
</span></span><span style=display:flex><span>            physical_device,
</span></span><span style=display:flex><span>            device,
</span></span><span style=display:flex><span>            graphics_queue,
</span></span><span style=display:flex><span>            present_queue,
</span></span><span style=display:flex><span>            swap_chain,
</span></span><span style=display:flex><span>            swap_chain_images,
</span></span><span style=display:flex><span>            swap_chain_image_format,
</span></span><span style=display:flex><span>            swap_chain_extent,
</span></span><span style=display:flex><span>            image_views,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_graphics_pipeline() {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=shader-modules>Shader Modules
<a class=heading-link href=#shader-modules><i class="fa fa-link" aria-hidden=true></i></a></h2><p>For the <a href=https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules>shaders</a>, that will all be the same as the tutorial, so I&rsquo;ll elude discussing it here. I&rsquo;d mostly be repeating the tutorial anyway. We&rsquo;ll similarly create a nice helper function for loading our shaders into the program:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>fn</span> read_file(filename: <span>&amp;</span><span>str</span>) -&gt; Vec&lt;<span>u8</span>&gt; {
</span></span><span style=display:flex><span>    fs::read(filename).expect(<span style=font-style:italic>&#34;Failed to read the file!&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yes, it&rsquo;s very impressive. Honestly this is so trivial to do we don&rsquo;t even need this function. Anyway, lets fetch our shader code for creating our pipeline:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_graphics_pipeline() {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_code = fs::read(<span style=font-style:italic>&#34;shaders/vert.spv&#34;</span>).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_code = fs::read(<span style=font-style:italic>&#34;shaders/frag.spv&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Then we need to create the actual shader modules out of our code:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_shader_module(device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device, code: Vec&lt;<span>u8</span>&gt;) -&gt; <span style=font-weight:700>vk</span>::ShaderModule {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> create_info = vk::ShaderModuleCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::SHADER_MODULE_CREATE_INFO,
</span></span><span style=display:flex><span>            code_size: <span style=font-weight:700>code</span>.len(),
</span></span><span style=display:flex><span>            p_code: <span style=font-weight:700>code</span>.as_ptr() <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> <span>u32</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { device.create_shader_module(&amp;create_info, None).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>As we&rsquo;ve seen many times already, the pattern is the same: create a <code>create_info</code> object for our specific construct, and then queue up a <code>create</code> function off of the specific necessary context (such as in this case, our logical device). And of course, we insert these calls into our graphics pipeline creation, where we conveniently at the end of the creation destroy the shader modules:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_graphics_pipeline(device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_code = fs::read(<span style=font-style:italic>&#34;shaders/vert.spv&#34;</span>).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_code = fs::read(<span style=font-style:italic>&#34;shaders/frag.spv&#34;</span>).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_module = VulkanDetails::create_shader_module(device, vert_shader_code);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_module = VulkanDetails::create_shader_module(device, frag_shader_code);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            device.destroy_shader_module(frag_shader_module, None);
</span></span><span style=display:flex><span>            device.destroy_shader_module(vert_shader_module, None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Don&rsquo;t worry! We&rsquo;ll make use of those modules at some point in that chunk of code, so it won&rsquo;t be for naught. One last step is setting up our stages:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_graphics_pipeline(device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_code = fs::read(<span style=font-style:italic>&#34;shaders/vert.spv&#34;</span>).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_code = fs::read(<span style=font-style:italic>&#34;shaders/frag.spv&#34;</span>).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_module = VulkanDetails::create_shader_module(device, vert_shader_code);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_module = VulkanDetails::create_shader_module(device, frag_shader_code);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_stage_info = vk::PipelineShaderStageCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO,
</span></span><span style=display:flex><span>            stage: <span style=font-weight:700>vk</span>::ShaderStageFlags::VERTEX,
</span></span><span style=display:flex><span>            module: <span style=font-weight:700>vert_shader_module</span>,
</span></span><span style=display:flex><span>            p_name: <span style=font-weight:700>CStr</span>::from_bytes_with_nul(<span style=font-style:italic>&#34;main\0&#34;</span>.as_bytes())
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>                .as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_stage_info = vk::PipelineShaderStageCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO,
</span></span><span style=display:flex><span>            stage: <span style=font-weight:700>vk</span>::ShaderStageFlags::FRAGMENT,
</span></span><span style=display:flex><span>            module: <span style=font-weight:700>frag_shader_module</span>,
</span></span><span style=display:flex><span>            p_name: <span style=font-weight:700>CStr</span>::from_bytes_with_nul(<span style=font-style:italic>&#34;main\0&#34;</span>.as_bytes())
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>                .as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> shader_stages = vec![vert_shader_stage_info, frag_shader_stage_info];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            device.destroy_shader_module(frag_shader_module, None);
</span></span><span style=display:flex><span>            device.destroy_shader_module(vert_shader_module, None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>That gives us step one: our shader code is now compiled and configured properly. Now on to stage two.</p><h2 id=fixed-functions>Fixed Functions
<a class=heading-link href=#fixed-functions><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Now that we have our shaders set up, we can move on to the <a href=https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions>fixed functions</a>. First, we configure our dynamic state:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> dynamic_states = vec![vk::DynamicState::VIEWPORT, vk::DynamicState::SCISSOR];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> dynamic_state = vk::PipelineDynamicStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_DYNAMIC_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            dynamic_state_count: <span style=font-weight:700>dynamic_states</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            p_dynamic_states: <span style=font-weight:700>dynamic_states</span>.as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>Then we move on to our vertex input:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> vertex_input_info = vk::PipelineVertexInputStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            vertex_binding_description_count: 0,
</span></span><span style=display:flex><span>            p_vertex_binding_descriptions: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            vertex_attribute_description_count: 0,
</span></span><span style=display:flex><span>            p_vertex_attribute_descriptions: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>Nothing particularly special, and basically identical to the C++. Then the input assembly:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> input_assembly = vk::PipelineInputAssemblyStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            topology: <span style=font-weight:700>vk</span>::PrimitiveTopology::TRIANGLE_LIST,
</span></span><span style=display:flex><span>            primitive_restart_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>Because we&rsquo;re not bothering with static creation of our viewport and scissor, we can just defer handling them until during drawing. So, we just move right on to the viewport state:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> viewport_state = vk::PipelineViewportStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_VIEWPORT_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            viewport_count: 1,
</span></span><span style=display:flex><span>            scissor_count: 1,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>The next meaty <code>create_info</code> is the rasterizer:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> rasterizer = vk::PipelineRasterizationStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            depth_clamp_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            rasterizer_discard_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            polygon_mode: <span style=font-weight:700>vk</span>::PolygonMode::FILL,
</span></span><span style=display:flex><span>            line_width: 1.0,
</span></span><span style=display:flex><span>            cull_mode: <span style=font-weight:700>vk</span>::CullModeFlags::BACK,
</span></span><span style=display:flex><span>            front_face: <span style=font-weight:700>vk</span>::FrontFace::CLOCKWISE,
</span></span><span style=display:flex><span>            depth_bias_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            depth_bias_constant_factor: 0.0,
</span></span><span style=display:flex><span>            depth_bias_clamp: 0.0,
</span></span><span style=display:flex><span>            depth_bias_slope_factor: 0.0,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>And then multisampling, which we leave disabled for now:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> multisampling = vk::PipelineMultisampleStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            sample_shading_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            rasterization_samples: <span style=font-weight:700>vk</span>::SampleCountFlags::TYPE_1,
</span></span><span style=display:flex><span>            min_sample_shading: 1.0,
</span></span><span style=display:flex><span>            p_sample_mask: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            alpha_to_coverage_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            alpha_to_one_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>We then set up our color blending, which we will also leave disabled for now:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> color_blend_attachment = vk::PipelineColorBlendAttachmentState {
</span></span><span style=display:flex><span>            color_write_mask: <span style=font-weight:700>vk</span>::ColorComponentFlags::R
</span></span><span style=display:flex><span>                | vk::ColorComponentFlags::G
</span></span><span style=display:flex><span>                | vk::ColorComponentFlags::B
</span></span><span style=display:flex><span>                | vk::ColorComponentFlags::A,
</span></span><span style=display:flex><span>            blend_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            src_color_blend_factor: <span style=font-weight:700>vk</span>::BlendFactor::ONE,
</span></span><span style=display:flex><span>            dst_color_blend_factor: <span style=font-weight:700>vk</span>::BlendFactor::ZERO,
</span></span><span style=display:flex><span>            color_blend_op: <span style=font-weight:700>vk</span>::BlendOp::ADD,
</span></span><span style=display:flex><span>            src_alpha_blend_factor: <span style=font-weight:700>vk</span>::BlendFactor::ONE,
</span></span><span style=display:flex><span>            dst_alpha_blend_factor: <span style=font-weight:700>vk</span>::BlendFactor::ZERO,
</span></span><span style=display:flex><span>            alpha_blend_op: <span style=font-weight:700>vk</span>::BlendOp::ADD,
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>Then the global color blending, which we just defer to the framebuffer-specific color blending:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> color_blending = vk::PipelineColorBlendStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            logic_op_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            logic_op: <span style=font-weight:700>vk</span>::LogicOp::COPY,
</span></span><span style=display:flex><span>            attachment_count: 1,
</span></span><span style=display:flex><span>            p_attachments: <span>&amp;</span><span style=font-weight:700>color_blend_attachment</span>,
</span></span><span style=display:flex><span>            blend_constants: [0.0, 0.0, 0.0, 0.0],
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>And with all of that we can finally make our pipeline&mldr; layout!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> pipeline_layout_info = vk::PipelineLayoutCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_LAYOUT_CREATE_INFO,
</span></span><span style=display:flex><span>            set_layout_count: 0,
</span></span><span style=display:flex><span>            p_set_layouts: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            push_constant_range_count: 0,
</span></span><span style=display:flex><span>            p_push_constant_ranges: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            device.destroy_shader_module(frag_shader_module, None);
</span></span><span style=display:flex><span>            device.destroy_shader_module(vert_shader_module, None);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            device
</span></span><span style=display:flex><span>                .create_pipeline_layout(&amp;pipeline_layout_info, None)
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><h2 id=render-pass>Render Pass
<a class=heading-link href=#render-pass><i class="fa fa-link" aria-hidden=true></i></a></h2><p>And of course during all of that we still have half a dozen structs we made and then never used. Why is that? Because we still need to set up the <a href=https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes>render pass</a>. This means a new function, which we first fill with our details on the color attachment:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_render_pass(swap_chain_image_format: <span>&amp;</span><span style=font-weight:700>vk</span>::Format) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> color_attachment = vk::AttachmentDescription {
</span></span><span style=display:flex><span>            format: *swap_chain_image_format,
</span></span><span style=display:flex><span>            samples: <span style=font-weight:700>vk</span>::SampleCountFlags::TYPE_1,
</span></span><span style=display:flex><span>            load_op: <span style=font-weight:700>vk</span>::AttachmentLoadOp::CLEAR,
</span></span><span style=display:flex><span>            store_op: <span style=font-weight:700>vk</span>::AttachmentStoreOp::STORE,
</span></span><span style=display:flex><span>            stencil_load_op: <span style=font-weight:700>vk</span>::AttachmentLoadOp::DONT_CARE,
</span></span><span style=display:flex><span>            stencil_store_op: <span style=font-weight:700>vk</span>::AttachmentStoreOp::DONT_CARE,
</span></span><span style=display:flex><span>            initial_layout: <span style=font-weight:700>vk</span>::ImageLayout::UNDEFINED,
</span></span><span style=display:flex><span>            final_layout: <span style=font-weight:700>vk</span>::ImageLayout::PRESENT_SRC_KHR,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Then we set up our subpass:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> color_attachment_ref = vk::AttachmentReference {
</span></span><span style=display:flex><span>            attachment: 0,
</span></span><span style=display:flex><span>            layout: <span style=font-weight:700>vk</span>::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> subpass = vk::SubpassDescription {
</span></span><span style=display:flex><span>            pipeline_bind_point: <span style=font-weight:700>vk</span>::PipelineBindPoint::GRAPHICS,
</span></span><span style=display:flex><span>            color_attachment_count: 1,
</span></span><span style=display:flex><span>            p_color_attachments: <span>&amp;</span><span style=font-weight:700>color_attachment_ref</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>With that all taken care of, we can create our render pass:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_render_pass(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        swap_chain_image_format: <span>&amp;</span><span style=font-weight:700>vk</span>::Format,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::RenderPass {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> color_attachment = vk::AttachmentDescription {
</span></span><span style=display:flex><span>            format: *swap_chain_image_format,
</span></span><span style=display:flex><span>            samples: <span style=font-weight:700>vk</span>::SampleCountFlags::TYPE_1,
</span></span><span style=display:flex><span>            load_op: <span style=font-weight:700>vk</span>::AttachmentLoadOp::CLEAR,
</span></span><span style=display:flex><span>            store_op: <span style=font-weight:700>vk</span>::AttachmentStoreOp::STORE,
</span></span><span style=display:flex><span>            stencil_load_op: <span style=font-weight:700>vk</span>::AttachmentLoadOp::DONT_CARE,
</span></span><span style=display:flex><span>            stencil_store_op: <span style=font-weight:700>vk</span>::AttachmentStoreOp::DONT_CARE,
</span></span><span style=display:flex><span>            initial_layout: <span style=font-weight:700>vk</span>::ImageLayout::UNDEFINED,
</span></span><span style=display:flex><span>            final_layout: <span style=font-weight:700>vk</span>::ImageLayout::PRESENT_SRC_KHR,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> color_attachment_ref = vk::AttachmentReference {
</span></span><span style=display:flex><span>            attachment: 0,
</span></span><span style=display:flex><span>            layout: <span style=font-weight:700>vk</span>::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> subpass = vk::SubpassDescription {
</span></span><span style=display:flex><span>            pipeline_bind_point: <span style=font-weight:700>vk</span>::PipelineBindPoint::GRAPHICS,
</span></span><span style=display:flex><span>            color_attachment_count: 1,
</span></span><span style=display:flex><span>            p_color_attachments: <span>&amp;</span><span style=font-weight:700>color_attachment_ref</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> render_pass_info = vk::RenderPassCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::RENDER_PASS_CREATE_INFO,
</span></span><span style=display:flex><span>            attachment_count: 1,
</span></span><span style=display:flex><span>            p_attachments: <span>&amp;</span><span style=font-weight:700>color_attachment</span>,
</span></span><span style=display:flex><span>            subpass_count: 1,
</span></span><span style=display:flex><span>            p_subpasses: <span>&amp;</span><span style=font-weight:700>subpass</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { device.create_render_pass(&amp;render_pass_info, None).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>With the render pass taken care of, the goal is on the horizon. We&rsquo;re almost there!</p><h2 id=the-graphics-pipeline>The Graphics Pipeline
<a class=heading-link href=#the-graphics-pipeline><i class="fa fa-link" aria-hidden=true></i></a></h2><p>All of those unused structs at the moment can now be used for the creation of the <a href=https://vulkan-tutorial.com/en/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion>graphics pipeline</a>. The net result looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_graphics_pipeline(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        render_pass: <span>&amp;</span><span style=font-weight:700>vk</span>::RenderPass,
</span></span><span style=display:flex><span>    ) -&gt; (vk::PipelineLayout, vk::Pipeline) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_code = fs::read(<span style=font-style:italic>&#34;shaders/vert.spv&#34;</span>).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_code = fs::read(<span style=font-style:italic>&#34;shaders/frag.spv&#34;</span>).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_module = VulkanDetails::create_shader_module(device, vert_shader_code);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_module = VulkanDetails::create_shader_module(device, frag_shader_code);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vert_shader_stage_info = vk::PipelineShaderStageCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO,
</span></span><span style=display:flex><span>            stage: <span style=font-weight:700>vk</span>::ShaderStageFlags::VERTEX,
</span></span><span style=display:flex><span>            module: <span style=font-weight:700>vert_shader_module</span>,
</span></span><span style=display:flex><span>            p_name: <span style=font-weight:700>CStr</span>::from_bytes_with_nul(<span style=font-style:italic>&#34;main\0&#34;</span>.as_bytes())
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>                .as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> frag_shader_stage_info = vk::PipelineShaderStageCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_SHADER_STAGE_CREATE_INFO,
</span></span><span style=display:flex><span>            stage: <span style=font-weight:700>vk</span>::ShaderStageFlags::FRAGMENT,
</span></span><span style=display:flex><span>            module: <span style=font-weight:700>frag_shader_module</span>,
</span></span><span style=display:flex><span>            p_name: <span style=font-weight:700>CStr</span>::from_bytes_with_nul(<span style=font-style:italic>&#34;main\0&#34;</span>.as_bytes())
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>                .as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> shader_stages = vec![vert_shader_stage_info, frag_shader_stage_info];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vertex_input_info = vk::PipelineVertexInputStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            vertex_binding_description_count: 0,
</span></span><span style=display:flex><span>            p_vertex_binding_descriptions: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            vertex_attribute_description_count: 0,
</span></span><span style=display:flex><span>            p_vertex_attribute_descriptions: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> input_assembly = vk::PipelineInputAssemblyStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            topology: <span style=font-weight:700>vk</span>::PrimitiveTopology::TRIANGLE_LIST,
</span></span><span style=display:flex><span>            primitive_restart_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> viewport_state = vk::PipelineViewportStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_VIEWPORT_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            viewport_count: 1,
</span></span><span style=display:flex><span>            scissor_count: 1,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> rasterizer = vk::PipelineRasterizationStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            depth_clamp_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            rasterizer_discard_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            polygon_mode: <span style=font-weight:700>vk</span>::PolygonMode::FILL,
</span></span><span style=display:flex><span>            line_width: 1.0,
</span></span><span style=display:flex><span>            cull_mode: <span style=font-weight:700>vk</span>::CullModeFlags::BACK,
</span></span><span style=display:flex><span>            front_face: <span style=font-weight:700>vk</span>::FrontFace::CLOCKWISE,
</span></span><span style=display:flex><span>            depth_bias_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            depth_bias_constant_factor: 0.0,
</span></span><span style=display:flex><span>            depth_bias_clamp: 0.0,
</span></span><span style=display:flex><span>            depth_bias_slope_factor: 0.0,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> multisampling = vk::PipelineMultisampleStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            sample_shading_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            rasterization_samples: <span style=font-weight:700>vk</span>::SampleCountFlags::TYPE_1,
</span></span><span style=display:flex><span>            min_sample_shading: 1.0,
</span></span><span style=display:flex><span>            p_sample_mask: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            alpha_to_coverage_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            alpha_to_one_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> color_blend_attachment = vk::PipelineColorBlendAttachmentState {
</span></span><span style=display:flex><span>            color_write_mask: <span style=font-weight:700>vk</span>::ColorComponentFlags::R
</span></span><span style=display:flex><span>                | vk::ColorComponentFlags::G
</span></span><span style=display:flex><span>                | vk::ColorComponentFlags::B
</span></span><span style=display:flex><span>                | vk::ColorComponentFlags::A,
</span></span><span style=display:flex><span>            blend_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            src_color_blend_factor: <span style=font-weight:700>vk</span>::BlendFactor::ONE,
</span></span><span style=display:flex><span>            dst_color_blend_factor: <span style=font-weight:700>vk</span>::BlendFactor::ZERO,
</span></span><span style=display:flex><span>            color_blend_op: <span style=font-weight:700>vk</span>::BlendOp::ADD,
</span></span><span style=display:flex><span>            src_alpha_blend_factor: <span style=font-weight:700>vk</span>::BlendFactor::ONE,
</span></span><span style=display:flex><span>            dst_alpha_blend_factor: <span style=font-weight:700>vk</span>::BlendFactor::ZERO,
</span></span><span style=display:flex><span>            alpha_blend_op: <span style=font-weight:700>vk</span>::BlendOp::ADD,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> color_blending = vk::PipelineColorBlendStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            logic_op_enable: <span style=font-weight:700>vk</span>::FALSE,
</span></span><span style=display:flex><span>            logic_op: <span style=font-weight:700>vk</span>::LogicOp::COPY,
</span></span><span style=display:flex><span>            attachment_count: 1,
</span></span><span style=display:flex><span>            p_attachments: <span>&amp;</span><span style=font-weight:700>color_blend_attachment</span>,
</span></span><span style=display:flex><span>            blend_constants: [0.0, 0.0, 0.0, 0.0],
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> dynamic_states = vec![vk::DynamicState::VIEWPORT, vk::DynamicState::SCISSOR];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> dynamic_state = vk::PipelineDynamicStateCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_DYNAMIC_STATE_CREATE_INFO,
</span></span><span style=display:flex><span>            dynamic_state_count: <span style=font-weight:700>dynamic_states</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            p_dynamic_states: <span style=font-weight:700>dynamic_states</span>.as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> pipeline_layout_info = vk::PipelineLayoutCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::PIPELINE_LAYOUT_CREATE_INFO,
</span></span><span style=display:flex><span>            set_layout_count: 0,
</span></span><span style=display:flex><span>            p_set_layouts: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            push_constant_range_count: 0,
</span></span><span style=display:flex><span>            p_push_constant_ranges: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> pipeline_layout = <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            device
</span></span><span style=display:flex><span>                .create_pipeline_layout(&amp;pipeline_layout_info, None)
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> pipeline_info = vk::GraphicsPipelineCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::GRAPHICS_PIPELINE_CREATE_INFO,
</span></span><span style=display:flex><span>            stage_count: 2,
</span></span><span style=display:flex><span>            p_stages: <span style=font-weight:700>shader_stages</span>.as_ptr(),
</span></span><span style=display:flex><span>            p_vertex_input_state: <span>&amp;</span><span style=font-weight:700>vertex_input_info</span>,
</span></span><span style=display:flex><span>            p_input_assembly_state: <span>&amp;</span><span style=font-weight:700>input_assembly</span>,
</span></span><span style=display:flex><span>            p_viewport_state: <span>&amp;</span><span style=font-weight:700>viewport_state</span>,
</span></span><span style=display:flex><span>            p_rasterization_state: <span>&amp;</span><span style=font-weight:700>rasterizer</span>,
</span></span><span style=display:flex><span>            p_multisample_state: <span>&amp;</span><span style=font-weight:700>multisampling</span>,
</span></span><span style=display:flex><span>            p_depth_stencil_state: <span style=font-weight:700>null</span>(),
</span></span><span style=display:flex><span>            p_color_blend_state: <span>&amp;</span><span style=font-weight:700>color_blending</span>,
</span></span><span style=display:flex><span>            p_dynamic_state: <span>&amp;</span><span style=font-weight:700>dynamic_state</span>,
</span></span><span style=display:flex><span>            layout: <span style=font-weight:700>pipeline_layout</span>,
</span></span><span style=display:flex><span>            render_pass: *render_pass,
</span></span><span style=display:flex><span>            subpass: 0,
</span></span><span style=display:flex><span>            base_pipeline_handle: <span style=font-weight:700>vk</span>::Pipeline::null(),
</span></span><span style=display:flex><span>            base_pipeline_index: -1,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> graphics_pipeline = <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            device
</span></span><span style=display:flex><span>                .create_graphics_pipelines(vk::PipelineCache::null(), &amp;[pipeline_info], None)
</span></span><span style=display:flex><span>                .unwrap()[0]
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            device.destroy_shader_module(frag_shader_module, None);
</span></span><span style=display:flex><span>            device.destroy_shader_module(vert_shader_module, None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        (pipeline_layout, graphics_pipeline)
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>It runs, everything plays nice, nothing starts screaming other than the sheer volume of validation layers confirming their existence. We have a graphics pipeline! Next, we will start arranging things so that we can actually make use of it.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>Â©
2022
Brad Dragun (LuuBluum)
Â·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script></body></html>