<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Brad Dragun (LuuBluum)"><meta name=description content="With the physical and logical devices now configured, we can move on to actually creating a Vulkan surface to draw on. From there, we can actually start fiddling with layers relevant to graphics! All of the code can be found at this repo."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Learning Vulkan with Rust, Part 4: Surfaces"><meta name=twitter:description content="With the physical and logical devices now configured, we can move on to actually creating a Vulkan surface to draw on. From there, we can actually start fiddling with layers relevant to graphics! All of the code can be found at this repo."><meta property="og:title" content="Learning Vulkan with Rust, Part 4: Surfaces"><meta property="og:description" content="With the physical and logical devices now configured, we can move on to actually creating a Vulkan surface to draw on. From there, we can actually start fiddling with layers relevant to graphics! All of the code can be found at this repo."><meta property="og:type" content="article"><meta property="og:url" content="https://LuuBluum.github.io/posts/post4rustvulkan/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-06T10:23:53-07:00"><meta property="article:modified_time" content="2022-08-06T10:23:53-07:00"><title>LuuBluum's Coding Blog</title><link rel=canonical href=https://LuuBluum.github.io/posts/post4rustvulkan/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>LuuBluum's Coding Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://LuuBluum.github.io/posts/post4rustvulkan/>Learning Vulkan with Rust, Part 4: Surfaces</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-08-06T10:23:53-07:00>August 6, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
11-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/rust/>Rust</a>
<span class=separator>â€¢</span>
<a href=/categories/vulkan/>Vulkan</a></div></div></header><div><p>With the <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families>physical</a> and <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues>logical</a> devices now configured, we can move on to actually creating a <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface>Vulkan surface</a> to draw on. From there, we can actually start fiddling with layers relevant to graphics! All of the code can be found at <a href=https://github.com/LuuBluum/Learning-Vulkan-with-Rust>this repo</a>.</p><p>It&rsquo;s with a lot of good fortune that the tutorial bothers to explain how to configure things for particular operating systems, because we don&rsquo;t get to rely on GLFW detecting the OS-specific settings for us. No, we have to do all the OS stuff ourself.</p><p>Or at least, the Windows stuff. If you&rsquo;re following along you can probably switch out the Window stuff for the respective operating system. As with the tutorial, we now keep track of a surface as well:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>HelloTriangleApplication</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, there&rsquo;s a problem with setting up this surface: it needs a handle to the window. The window we explicitly had to move out of our struct due to causing problems with the event loop of winit. We can try handling it the way we tried prior, but then we run into another issue:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>error[E0599]: no method named `raw_window_handle` found <span style=font-weight:700>for</span> reference `&amp;Window` <span style=font-weight:700>in</span> the current scope
</span></span><span style=display:flex><span>   --&gt; src<span>\</span>surfaces.rs:129:26
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>129 |             hwnd: window.raw_window_handle()
</span></span><span style=display:flex><span>    |                          ^^^^^^^^^^^^^^^^^ method <span style=font-weight:700>not</span> found <span style=font-weight:700>in</span> `&amp;Window`
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>    = help: items <span style=font-weight:700>from</span> traits can only be used <span style=font-weight:700>if</span> the trait <span style=font-weight:700>is</span> <span style=font-weight:700>in</span> scope
</span></span><span style=display:flex><span>help: the following trait <span style=font-weight:700>is</span> implemented but <span style=font-weight:700>not</span> <span style=font-weight:700>in</span> scope; perhaps <span style=font-weight:700>add</span> a `<span style=font-weight:700>use</span>` <span style=font-weight:700>for</span> it:
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>1   | <span style=font-weight:700>use</span> raw_window_handle::HasRawWindowHandle;
</span></span><span style=display:flex><span>    |
</span></span></code></pre></div><p>Seems we need another crate. Stick this on the end of the <code>Cargo.toml</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>raw-window-handle = &#34;0.5.0&#34;
</span></span></code></pre></div><p>And now we can use it as well:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>use</span> raw_window_handle::HasRawWindowHandle;
</span></span></code></pre></div><p>Finally, some progress. We can start making our function to create a surface:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>fn</span> create_surface(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) -&gt; <span style=font-weight:700>vk</span>::SurfaceKHR {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface_create_info =
</span></span></code></pre></div><p>Except&mldr; a problem. We need the create info, which needs details from the raw window handle. However, it seems we now yield not a raw window handle, but a raw window handle wrapped in an enum for all the potential operating systems we might be dealing with. It seems we&rsquo;re going to be handling this OS-agnostically after all! In terms of actual OS support, we have&mldr; Xcb, Xlib, Win32, Android, and Wayland. Our raw window handle can be more OSes than that, so we&rsquo;ll have to do some error handling on top of that. The end result looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_surface(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window, entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry, instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance) -&gt; <span style=font-weight:700>VkResult</span>&lt;vk::SurfaceKHR&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>match</span> window.raw_window_handle() {
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::AndroidNdk(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::AndroidSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::ANDROID_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.a_native_window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> android_surface = AndroidSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { android_surface.create_android_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Win32(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::Win32SurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::WIN32_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    hwnd: <span style=font-weight:700>handle</span>.hwnd,
</span></span><span style=display:flex><span>                    hinstance: <span style=font-weight:700>handle</span>.hinstance,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> win32_surface = Win32Surface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { win32_surface.create_win32_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Wayland(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::WaylandSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::WAYLAND_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    display: <span style=font-weight:700>handle</span>.surface,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> wayland_surface = WaylandSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { wayland_surface.create_wayland_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Xcb(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::XcbSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::XCB_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> xcb_surface = XcbSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { xcb_surface.create_xcb_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Xlib(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::XlibSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::XLIB_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> xlib_surface = XlibSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { xlib_surface.create_xlib_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            _ =&gt; Err(vk::Result::ERROR_INITIALIZATION_FAILED)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>However, we&rsquo;re still not free from that pesky partial move problem. There is a solution, though: break <code>cleanup</code> off of our struct and make it a function for a new struct that takes just all our Vulkan stuff, and then the move should work out fine.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>error[E0507]: cannot move <span style=font-weight:700>out</span> of `self.entry`, a captured variable <span style=font-weight:700>in</span> an `FnMut` closure
</span></span><span style=display:flex><span>   --&gt; src<span>\</span>surfaces.rs:253:32
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>243 |       pub fn run(mut self) -&gt; ! <span>{</span>
</span></span><span style=display:flex><span>    |                  ------<span style=font-style:italic>-- captured outer variable
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>244 |           self.event_loop.run(move |event, _, control_flow| <span>{</span>
</span></span><span style=display:flex><span>    |  _____________________________-
</span></span><span style=display:flex><span>245 | |             *control_flow = ControlFlow::Wait;
</span></span><span style=display:flex><span>246 | |
</span></span><span style=display:flex><span>247 | |             <span style=font-weight:700>match</span> event <span>{</span>
</span></span><span style=display:flex><span>...   |
</span></span><span style=display:flex><span>253 | |                         entry: self.entry,
</span></span><span style=display:flex><span>    | |                                ^^^^^^^^^^ move occurs because `self.entry` has type `ash::Entry`, which does <span style=font-weight:700>not</span> implement the `Copy` trait
</span></span><span style=display:flex><span>...   |
</span></span><span style=display:flex><span>264 | |             <span>}</span>
</span></span><span style=display:flex><span>265 | |         <span>}</span>);
</span></span><span style=display:flex><span>    | |_________- captured <span style=font-weight:700>by</span> this `FnMut` closure
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error[E0507]: cannot move <span style=font-weight:700>out</span> of `self.instance`, a captured variable <span style=font-weight:700>in</span> an `FnMut` closure
</span></span><span style=display:flex><span>   --&gt; src<span>\</span>surfaces.rs:254:35
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>243 |       pub fn run(mut self) -&gt; ! <span>{</span>
</span></span><span style=display:flex><span>    |                  ------<span style=font-style:italic>-- captured outer variable
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>244 |           self.event_loop.run(move |event, _, control_flow| <span>{</span>
</span></span><span style=display:flex><span>    |  _____________________________-
</span></span><span style=display:flex><span>245 | |             *control_flow = ControlFlow::Wait;
</span></span><span style=display:flex><span>246 | |
</span></span><span style=display:flex><span>247 | |             <span style=font-weight:700>match</span> event <span>{</span>
</span></span><span style=display:flex><span>...   |
</span></span><span style=display:flex><span>254 | |                         instance: self.instance,
</span></span><span style=display:flex><span>    | |                                   ^^^^^^^^^^^^^ move occurs because `self.instance` has type `ash::Instance`, which does <span style=font-weight:700>not</span> implement the `Copy` trait
</span></span><span style=display:flex><span>...   |
</span></span><span style=display:flex><span>264 | |             <span>}</span>
</span></span><span style=display:flex><span>265 | |         <span>}</span>);
</span></span><span style=display:flex><span>    | |_________- captured <span style=font-weight:700>by</span> this `FnMut` closure
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error[E0507]: cannot move <span style=font-weight:700>out</span> of `self.device`, a captured variable <span style=font-weight:700>in</span> an `FnMut` closure
</span></span><span style=display:flex><span>   --&gt; src<span>\</span>surfaces.rs:258:33
</span></span><span style=display:flex><span>    |
</span></span><span style=display:flex><span>243 |       pub fn run(mut self) -&gt; ! <span>{</span>
</span></span><span style=display:flex><span>    |                  ------<span style=font-style:italic>-- captured outer variable
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>244 |           self.event_loop.run(move |event, _, control_flow| <span>{</span>
</span></span><span style=display:flex><span>    |  _____________________________-
</span></span><span style=display:flex><span>245 | |             *control_flow = ControlFlow::Wait;
</span></span><span style=display:flex><span>246 | |
</span></span><span style=display:flex><span>247 | |             <span style=font-weight:700>match</span> event <span>{</span>
</span></span><span style=display:flex><span>...   |
</span></span><span style=display:flex><span>258 | |                         device: self.device,
</span></span><span style=display:flex><span>    | |                                 ^^^^^^^^^^^ move occurs because `self.device` has type `ash::Device`, which does <span style=font-weight:700>not</span> implement the `Copy` trait
</span></span><span style=display:flex><span>...   |
</span></span><span style=display:flex><span>264 | |             <span>}</span>
</span></span><span style=display:flex><span>265 | |         <span>}</span>);
</span></span><span style=display:flex><span>    | |_________- captured <span style=font-weight:700>by</span> this `FnMut` closure
</span></span></code></pre></div><p>Or not. Seems a bit more toying around is necessary.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span>&lt;&#39;a&gt; {
</span></span><span style=display:flex><span>    entry: <span>&amp;</span> &#39;a <span style=font-weight:700>mut</span> ash::Entry,
</span></span><span style=display:flex><span>    instance: <span>&amp;</span> &#39;a <span style=font-weight:700>mut</span> ash::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span>&amp;</span> &#39;a <span style=font-weight:700>mut</span> vk::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span>&amp;</span> &#39;a <span style=font-weight:700>mut</span> vk::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span>&amp;</span> &#39;a <span style=font-weight:700>mut</span> vk::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span>&amp;</span> &#39;a <span style=font-weight:700>mut</span> ash::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span>&amp;</span> &#39;a <span style=font-weight:700>mut</span> vk::Queue,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> Drop <span style=font-weight:700>for</span> VulkanDetails&lt;&#39;_&gt; {
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> drop(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance).destroy_debug_utils_messenger(*self.debug_messenger, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And with that, our <code>run</code> now looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(<span style=font-weight:700>mut</span> self) -&gt; ! {
</span></span><span style=display:flex><span>        self.event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Wait;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; {
</span></span><span style=display:flex><span>                    VulkanDetails {
</span></span><span style=display:flex><span>                        entry: <span>&amp;</span><span style=font-weight:700>mut</span> self.entry,
</span></span><span style=display:flex><span>                        instance: <span>&amp;</span><span style=font-weight:700>mut</span> self.instance,
</span></span><span style=display:flex><span>                        debug_messenger: <span>&amp;</span><span style=font-weight:700>mut</span> self.debug_messenger,
</span></span><span style=display:flex><span>                        surface: <span>&amp;</span><span style=font-weight:700>mut</span> self.surface,
</span></span><span style=display:flex><span>                        physical_device: <span>&amp;</span><span style=font-weight:700>mut</span> self.physical_device,
</span></span><span style=display:flex><span>                        device: <span>&amp;</span><span style=font-weight:700>mut</span> self.device,
</span></span><span style=display:flex><span>                        graphics_queue: <span>&amp;</span><span style=font-weight:700>mut</span> self.graphics_queue,
</span></span><span style=display:flex><span>                    };
</span></span><span style=display:flex><span>                    *control_flow = ControlFlow::Exit
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                _ =&gt; (),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>However, now we need to actually destroy the surface. This is simple enough:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>impl</span> Drop <span style=font-weight:700>for</span> VulkanDetails&lt;&#39;_&gt; {
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> drop(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(self.entry, self.instance).destroy_debug_utils_messenger(*self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(self.entry, self.instance).destroy_surface(*self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And with that, we now have a surface integrated, and another struct to maintain. We can probably handle this a bit better. Let&rsquo;s fold that struct into our application and create a cleanup function that runs just on that struct, to avoid the partial move. And while we&rsquo;re at it let&rsquo;s remove all those panics:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>use</span> std::ffi::CStr;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> std::ffi::c_void;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::prelude::*;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::{vk, Entry};
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> winit::{
</span></span><span style=display:flex><span>    event::{Event, WindowEvent},
</span></span><span style=display:flex><span>    event_loop::{ControlFlow, EventLoop},
</span></span><span style=display:flex><span>    window::WindowBuilder,
</span></span><span style=display:flex><span>    dpi::PhysicalSize,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::khr::{AndroidSurface, WaylandSurface, Win32Surface, XcbSurface, XlibSurface};
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::khr::Surface;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::ext::DebugUtils;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> raw_window_handle::HasRawWindowHandle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> WIDTH : <span>u32</span> = 800;
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> HEIGHT : <span>u32</span> = 600;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> VALIDATION_LAYERS : <span>&amp;</span>[*<span style=font-weight:700>const</span> <span>i8</span>] = &amp;[
</span></span><span style=display:flex><span>    <span style=font-weight:700>unsafe</span> { CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;VK_LAYER_KHRONOS_validation\0&#34;</span>.as_bytes()).as_ptr() }
</span></span><span style=display:flex><span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> REQUIRED_EXTENSIONS : <span>&amp;</span>[*<span style=font-weight:700>const</span> <span>i8</span>] = &amp;[
</span></span><span style=display:flex><span>    Surface::name().as_ptr(),
</span></span><span style=display:flex><span>    Win32Surface::name().as_ptr(),
</span></span><span style=display:flex><span>    DebugUtils::name().as_ptr(),
</span></span><span style=display:flex><span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>extern</span> <span style=font-style:italic>&#34;system&#34;</span> <span style=font-weight:700>fn</span> debug_callback(
</span></span><span style=display:flex><span>    _message_severity: <span style=font-weight:700>vk</span>::DebugUtilsMessageSeverityFlagsEXT,
</span></span><span style=display:flex><span>    _message_type: <span style=font-weight:700>vk</span>::DebugUtilsMessageTypeFlagsEXT,
</span></span><span style=display:flex><span>    callback_data: *<span style=font-weight:700>const</span> vk::DebugUtilsMessengerCallbackDataEXT,
</span></span><span style=display:flex><span>    _: *<span style=font-weight:700>mut</span> c_void,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::Bool32 {
</span></span><span style=display:flex><span>        print!(<span style=font-style:italic>&#34;validation layer: {}&#34;</span>, <span style=font-weight:700>unsafe</span> { CStr::from_ptr((*callback_data).p_message).to_str().unwrap() });
</span></span><span style=display:flex><span>        vk::FALSE
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>}    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>HelloTriangleApplication</span> {
</span></span><span style=display:flex><span>    event_loop: <span style=font-weight:700>winit</span>::event_loop::EventLoop&lt;()&gt;,
</span></span><span style=display:flex><span>    window: <span style=font-weight:700>winit</span>::window::Window,
</span></span><span style=display:flex><span>    vulkan_details: <span style=font-weight:700>VulkanDetails</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> VulkanDetails {
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (entry, instance, debug_messenger, surface, physical_device, device, graphics_queue) = VulkanDetails::init_vulkan(&amp;window);
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            entry: <span style=font-weight:700>entry</span>,
</span></span><span style=display:flex><span>            instance: <span style=font-weight:700>instance</span>,
</span></span><span style=display:flex><span>            debug_messenger: <span style=font-weight:700>debug_messenger</span>,
</span></span><span style=display:flex><span>            surface: <span style=font-weight:700>surface</span>,
</span></span><span style=display:flex><span>            physical_device: <span style=font-weight:700>physical_device</span>,
</span></span><span style=display:flex><span>            device: <span style=font-weight:700>device</span>,
</span></span><span style=display:flex><span>            graphics_queue: <span style=font-weight:700>graphics_queue</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) -&gt; (
</span></span><span style=display:flex><span>        ash::Entry,
</span></span><span style=display:flex><span>        ash::Instance,
</span></span><span style=display:flex><span>        vk::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>        vk::SurfaceKHR,
</span></span><span style=display:flex><span>        vk::PhysicalDevice,
</span></span><span style=display:flex><span>        ash::Device,
</span></span><span style=display:flex><span>        vk::Queue,
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> entry = Entry::linked();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> instance = VulkanDetails::create_instance(&amp;entry).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> debug_messenger = VulkanDetails::create_debug_messenger(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface = VulkanDetails::create_surface(&amp;window, &amp;entry, &amp;instance).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> physical_device = VulkanDetails::pick_physical_device(&amp;instance).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device = VulkanDetails::create_logical_device(&amp;instance, &amp;physical_device);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> graphics_queue = <span style=font-weight:700>unsafe</span> { device.get_device_queue(VulkanDetails::find_queue_familes(&amp;instance, &amp;physical_device).unwrap() <span style=font-weight:700>as</span> <span>u32</span>, 0) };
</span></span><span style=display:flex><span>        (entry, instance, debug_messenger, surface, physical_device, device, graphics_queue)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_instance(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry) -&gt; <span style=font-weight:700>VkResult</span>&lt;ash::Instance&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> !VulkanDetails::check_validation_layer_support(&amp;entry)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> Err(vk::Result::ERROR_INITIALIZATION_FAILED)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> app_info = vk::ApplicationInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::APPLICATION_INFO,
</span></span><span style=display:flex><span>            p_application_name: <span style=font-weight:700>unsafe</span> { CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;Hello Triangle\0&#34;</span>.as_bytes()).as_ptr() },
</span></span><span style=display:flex><span>            application_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            p_engine_name: <span style=font-weight:700>unsafe</span> { CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;No Engine\0&#34;</span>.as_bytes()).as_ptr() },
</span></span><span style=display:flex><span>            engine_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            api_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> create_info = vk::InstanceCreateInfo {
</span></span><span style=display:flex><span>            p_application_info: <span>&amp;</span><span style=font-weight:700>app_info</span>,
</span></span><span style=display:flex><span>            enabled_layer_count: <span style=font-weight:700>VALIDATION_LAYERS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_layer_names: <span style=font-weight:700>VALIDATION_LAYERS</span>.as_ptr(),
</span></span><span style=display:flex><span>            enabled_extension_count: <span style=font-weight:700>REQUIRED_EXTENSIONS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_extension_names: <span style=font-weight:700>REQUIRED_EXTENSIONS</span>.as_ptr(),
</span></span><span style=display:flex><span>            p_next: <span>&amp;</span><span style=font-weight:700>VulkanDetails</span>::populate_debug_messenger_create_info() <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> _ <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> c_void,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { entry.create_instance(&amp;create_info, None) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> check_validation_layer_support(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry) -&gt; <span>bool</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> layer_properties = entry.enumerate_instance_layer_properties().unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> layer <span style=font-weight:700>in</span> VALIDATION_LAYERS {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> <span style=font-weight:700>let</span> None = layer_properties.iter().find(|l| {
</span></span><span style=display:flex><span>                <span style=font-style:italic>// This horrible construction is because Vulkan operates with C strings and Rust does not
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>               <span style=font-weight:700>unsafe</span> { &amp;CStr::from_ptr(l.layer_name.as_ptr()).to_str().unwrap() == &amp;CStr::from_ptr(*layer).to_str().unwrap() }
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_debug_messenger(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry, instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance) -&gt; <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { DebugUtils::new(&amp;entry, &amp;instance).create_debug_utils_messenger(&amp;VulkanDetails::populate_debug_messenger_create_info(), None).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_surface(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window, entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry, instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance) -&gt; <span style=font-weight:700>VkResult</span>&lt;vk::SurfaceKHR&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>match</span> window.raw_window_handle() {
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::AndroidNdk(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::AndroidSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::ANDROID_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.a_native_window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> android_surface = AndroidSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { android_surface.create_android_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Win32(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::Win32SurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::WIN32_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    hwnd: <span style=font-weight:700>handle</span>.hwnd,
</span></span><span style=display:flex><span>                    hinstance: <span style=font-weight:700>handle</span>.hinstance,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> win32_surface = Win32Surface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { win32_surface.create_win32_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Wayland(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::WaylandSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::WAYLAND_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    display: <span style=font-weight:700>handle</span>.surface,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> wayland_surface = WaylandSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { wayland_surface.create_wayland_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Xcb(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::XcbSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::XCB_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> xcb_surface = XcbSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { xcb_surface.create_xcb_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Xlib(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::XlibSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::XLIB_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> xlib_surface = XlibSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { xlib_surface.create_xlib_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            _ =&gt; Err(vk::Result::ERROR_INITIALIZATION_FAILED)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> populate_debug_messenger_create_info() -&gt; <span style=font-weight:700>vk</span>::DebugUtilsMessengerCreateInfoEXT {
</span></span><span style=display:flex><span>        vk::DebugUtilsMessengerCreateInfoEXT {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
</span></span><span style=display:flex><span>            message_severity: <span style=font-weight:700>vk</span>::DebugUtilsMessageSeverityFlagsEXT::VERBOSE |
</span></span><span style=display:flex><span>                              vk::DebugUtilsMessageSeverityFlagsEXT::WARNING |
</span></span><span style=display:flex><span>                              vk::DebugUtilsMessageSeverityFlagsEXT::ERROR,
</span></span><span style=display:flex><span>            message_type: <span style=font-weight:700>vk</span>::DebugUtilsMessageTypeFlagsEXT::GENERAL |
</span></span><span style=display:flex><span>                          vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION |
</span></span><span style=display:flex><span>                          vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
</span></span><span style=display:flex><span>            pfn_user_callback: Some(debug_callback),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> pick_physical_device(instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance) -&gt; <span style=font-weight:700>VkResult</span>&lt;vk::PhysicalDevice&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> physical_device: Option&lt;vk::PhysicalDevice&gt; = None;
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> devices = <span style=font-weight:700>unsafe</span> { instance.enumerate_physical_devices().unwrap() };
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> devices.len() == 0 {
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> Err(vk::Result::ERROR_INITIALIZATION_FAILED)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> device <span style=font-weight:700>in</span> devices {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> VulkanDetails::is_device_suitable(&amp;instance, &amp;device) {
</span></span><span style=display:flex><span>                physical_device = Some(device);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        physical_device.ok_or(vk::Result::ERROR_INITIALIZATION_FAILED)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> is_device_suitable(instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance, device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice) -&gt; <span>bool</span> {
</span></span><span style=display:flex><span>        VulkanDetails::find_queue_familes(instance, device).is_some()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> find_queue_familes(instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance, device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice) -&gt; Option&lt;<span>usize</span>&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> queue_family_properties = <span style=font-weight:700>unsafe</span> { instance.get_physical_device_queue_family_properties(*device) };
</span></span><span style=display:flex><span>        queue_family_properties.iter().position(|&amp;queue_family| queue_family.queue_flags &amp; vk::QueueFlags::GRAPHICS == vk::QueueFlags::GRAPHICS)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_logical_device(instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance, physical_device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice) -&gt; <span style=font-weight:700>ash</span>::Device {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device_queue_create_info = vk::DeviceQueueCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DEVICE_QUEUE_CREATE_INFO,
</span></span><span style=display:flex><span>            queue_family_index: <span style=font-weight:700>VulkanDetails</span>::find_queue_familes(instance, physical_device).unwrap() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            queue_count: 1,
</span></span><span style=display:flex><span>            p_queue_priorities: <span>&amp;</span>1.0,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device_features = vk::PhysicalDeviceFeatures {
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device_create_info = vk::DeviceCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DEVICE_CREATE_INFO,
</span></span><span style=display:flex><span>            queue_create_info_count: 1,
</span></span><span style=display:flex><span>            p_queue_create_infos: <span>&amp;</span><span style=font-weight:700>device_queue_create_info</span>,
</span></span><span style=display:flex><span>            p_enabled_features: <span>&amp;</span><span style=font-weight:700>device_features</span>,
</span></span><span style=display:flex><span>            enabled_layer_count: <span style=font-weight:700>VALIDATION_LAYERS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_layer_names: <span style=font-weight:700>VALIDATION_LAYERS</span>.as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { instance.create_device(*physical_device, &amp;device_create_info, None).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance).destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(&amp;self.entry, &amp;self.instance).destroy_surface(self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> HelloTriangleApplication {
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new() -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (event_loop, window) = HelloTriangleApplication::init_window().unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vulkan_details = VulkanDetails::new(&amp;window);
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            event_loop: <span style=font-weight:700>event_loop</span>,
</span></span><span style=display:flex><span>            window: <span style=font-weight:700>window</span>,
</span></span><span style=display:flex><span>            vulkan_details: <span style=font-weight:700>vulkan_details</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(<span style=font-weight:700>mut</span> self) -&gt; ! {
</span></span><span style=display:flex><span>        self.event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Wait;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; {
</span></span><span style=display:flex><span>                    self.vulkan_details.cleanup();
</span></span><span style=display:flex><span>                    *control_flow = ControlFlow::Exit
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                _ =&gt; (),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_window() -&gt; Result&lt;(winit::event_loop::EventLoop&lt;()&gt;, winit::window::Window), winit::error::OsError&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> event_loop = EventLoop::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> window = WindowBuilder::new()
</span></span><span style=display:flex><span>            .with_resizable(<span style=font-weight:700>false</span>)
</span></span><span style=display:flex><span>            .with_inner_size(PhysicalSize::new(WIDTH, HEIGHT))
</span></span><span style=display:flex><span>            .build(&amp;event_loop)?;
</span></span><span style=display:flex><span>        Ok((event_loop, window))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can move on to adding support for presentation queues. This requires modifying our <code>find_queue_families</code> function to output two indices:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> find_queue_familes(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry, instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance, device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice, surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR) -&gt; (Option&lt;<span>usize</span>&gt;, Option&lt;<span>usize</span>&gt;) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> queue_family_properties = <span style=font-weight:700>unsafe</span> { instance.get_physical_device_queue_family_properties(*device) };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface_details = Surface::new(entry, instance);
</span></span><span style=display:flex><span>        ( queue_family_properties.iter().position(|&amp;queue_family| queue_family.queue_flags &amp; vk::QueueFlags::GRAPHICS == vk::QueueFlags::GRAPHICS),
</span></span><span style=display:flex><span>          queue_family_properties.iter().enumerate().position(|(index, _)| <span style=font-weight:700>unsafe</span> { surface_details.get_physical_device_surface_support(*device, index <span style=font-weight:700>as</span> <span>u32</span>, *surface).unwrap() })
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>The rest of the changes is a consequence of dealing with the entry and surface parameters to this function, and the fact that it now returns details on two queues. Naturally, this means our logical device now needs to deal with two queues:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_logical_device(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry, instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance, physical_device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice, surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR) -&gt; <span style=font-weight:700>ash</span>::Device {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (gq, pq) = VulkanDetails::find_queue_familes(entry, instance, physical_device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> queues = HashSet::new();
</span></span><span style=display:flex><span>        queues.insert(gq.unwrap() <span style=font-weight:700>as</span> <span>u32</span>);
</span></span><span style=display:flex><span>        queues.insert(pq.unwrap() <span style=font-weight:700>as</span> <span>u32</span>);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> device_queue_create_infos = Vec::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> queue <span style=font-weight:700>in</span> queues {
</span></span><span style=display:flex><span>            device_queue_create_infos.push(
</span></span><span style=display:flex><span>                vk::DeviceQueueCreateInfo {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::DEVICE_QUEUE_CREATE_INFO,
</span></span><span style=display:flex><span>                    queue_family_index: <span style=font-weight:700>queue</span>,
</span></span><span style=display:flex><span>                    queue_count: 1,
</span></span><span style=display:flex><span>                    p_queue_priorities: <span>&amp;</span>1.0,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device_features = vk::PhysicalDeviceFeatures {
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device_create_info = vk::DeviceCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DEVICE_CREATE_INFO,
</span></span><span style=display:flex><span>            queue_create_info_count: <span style=font-weight:700>device_queue_create_infos</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            p_queue_create_infos: <span style=font-weight:700>device_queue_create_infos</span>.as_ptr(),
</span></span><span style=display:flex><span>            p_enabled_features: <span>&amp;</span><span style=font-weight:700>device_features</span>,
</span></span><span style=display:flex><span>            enabled_layer_count: <span style=font-weight:700>VALIDATION_LAYERS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_layer_names: <span style=font-weight:700>VALIDATION_LAYERS</span>.as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { instance.create_device(*physical_device, &amp;device_create_info, None).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>As for actaully creating the <code>present_queue</code>, it&rsquo;s a copy-paste job from <code>graphics_queue</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    present_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> VulkanDetails {
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (entry, instance, debug_messenger, surface, physical_device, device, graphics_queue, present_queue) = VulkanDetails::init_vulkan(&amp;window);
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            entry: <span style=font-weight:700>entry</span>,
</span></span><span style=display:flex><span>            instance: <span style=font-weight:700>instance</span>,
</span></span><span style=display:flex><span>            debug_messenger: <span style=font-weight:700>debug_messenger</span>,
</span></span><span style=display:flex><span>            surface: <span style=font-weight:700>surface</span>,
</span></span><span style=display:flex><span>            physical_device: <span style=font-weight:700>physical_device</span>,
</span></span><span style=display:flex><span>            device: <span style=font-weight:700>device</span>,
</span></span><span style=display:flex><span>            graphics_queue: <span style=font-weight:700>graphics_queue</span>,
</span></span><span style=display:flex><span>            present_queue: <span style=font-weight:700>present_queue</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) -&gt; (
</span></span><span style=display:flex><span>        ash::Entry,
</span></span><span style=display:flex><span>        ash::Instance,
</span></span><span style=display:flex><span>        vk::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>        vk::SurfaceKHR,
</span></span><span style=display:flex><span>        vk::PhysicalDevice,
</span></span><span style=display:flex><span>        ash::Device,
</span></span><span style=display:flex><span>        vk::Queue,
</span></span><span style=display:flex><span>        vk::Queue,
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> entry = Entry::linked();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> instance = VulkanDetails::create_instance(&amp;entry).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> debug_messenger = VulkanDetails::create_debug_messenger(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface = VulkanDetails::create_surface(&amp;window, &amp;entry, &amp;instance).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> physical_device = VulkanDetails::pick_physical_device(&amp;entry, &amp;instance, &amp;surface).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device = VulkanDetails::create_logical_device(&amp;entry, &amp;instance, &amp;physical_device, &amp;surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_index, present_queue_index) = VulkanDetails::find_queue_familes(&amp;entry, &amp;instance, &amp;physical_device, &amp;surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> graphics_queue = <span style=font-weight:700>unsafe</span> { device.get_device_queue(graphics_queue_index.unwrap() <span style=font-weight:700>as</span> <span>u32</span>, 0) };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> present_queue = <span style=font-weight:700>unsafe</span> { device.get_device_queue(present_queue_index.unwrap() <span style=font-weight:700>as</span> <span>u32</span>, 0) };
</span></span><span style=display:flex><span>        (entry, instance, debug_messenger, surface, physical_device, device, graphics_queue, present_queue)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We now have both a graphics queue and a presentation queue, and even a surface to draw to. It&rsquo;s even OS-agnostic! Well&mldr; sorta OS-agnostic. We don&rsquo;t really deal with the ramifications of what extensions are necessary for OSes other than Windows. Oh well. It works, it runs, a window opens and the console vomits endless validation layer information but none of them are errors. Next is the swap chain&mldr; which will be quite the hurdle indeed.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>Â©
2022
Brad Dragun (LuuBluum)
Â·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script></body></html>