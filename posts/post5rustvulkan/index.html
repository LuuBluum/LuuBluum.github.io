<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Brad Dragun (LuuBluum)"><meta name=description content="With a surface provided, we can now move to one of the more daunting components of Vulkan: the swap chain. After that, we need to take care of image views so that the swap chain has something to actually swap in. This will probably be the most challenging bit so far. Probably. All of the code can be found at this repo."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Learning Vulkan with Rust, Part 5: The Swap Chain and Image Views"><meta name=twitter:description content="With a surface provided, we can now move to one of the more daunting components of Vulkan: the swap chain. After that, we need to take care of image views so that the swap chain has something to actually swap in. This will probably be the most challenging bit so far. Probably. All of the code can be found at this repo."><meta property="og:title" content="Learning Vulkan with Rust, Part 5: The Swap Chain and Image Views"><meta property="og:description" content="With a surface provided, we can now move to one of the more daunting components of Vulkan: the swap chain. After that, we need to take care of image views so that the swap chain has something to actually swap in. This will probably be the most challenging bit so far. Probably. All of the code can be found at this repo."><meta property="og:type" content="article"><meta property="og:url" content="https://LuuBluum.github.io/posts/post5rustvulkan/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-06T20:19:44-07:00"><meta property="article:modified_time" content="2022-08-06T20:19:44-07:00"><title>LuuBluum's Coding Blog</title><link rel=canonical href=https://LuuBluum.github.io/posts/post5rustvulkan/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.101.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>LuuBluum's Coding Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://LuuBluum.github.io/posts/post5rustvulkan/>Learning Vulkan with Rust, Part 5: The Swap Chain and Image Views</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-08-06T20:19:44-07:00>August 6, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
11-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/rust/>Rust</a>
<span class=separator>â€¢</span>
<a href=/categories/vulkan/>Vulkan</a></div></div></header><div><p>With a <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface>surface</a> provided, we can now move to one of the more daunting components of Vulkan: the <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain>swap chain</a>. After that, we need to take care of <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Image_views>image views</a> so that the swap chain has something to actually swap in. This will probably be the most challenging bit so far. Probably. All of the code can be found at <a href=https://github.com/LuuBluum/Learning-Vulkan-with-Rust>this repo</a>.</p><p>We first start with yet another clunky means of figuring out whether or not we support a feature:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>const</span> DEVICE_EXTENSIONS: <span>&amp;</span>[*<span style=font-weight:700>const</span> <span>i8</span>] = &amp;[<span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>    CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;VK_KHR_swapchain\0&#34;</span>.as_bytes()).as_ptr()
</span></span><span style=display:flex><span>}];
</span></span></code></pre></div><p>We need to handle this at the device level, which means creating yet another function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> is_device_suitable(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span>bool</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_index, present_queue_index) =
</span></span><span style=display:flex><span>            VulkanDetails::find_queue_familes(entry, instance, device, surface);
</span></span><span style=display:flex><span>        graphics_queue_index.is_some()
</span></span><span style=display:flex><span>            &amp;&amp; present_queue_index.is_some()
</span></span><span style=display:flex><span>            &amp;&amp; VulkanDetails::check_device_extension_support(instance, device)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> check_device_extension_support(
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    ) -&gt; <span>bool</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> extension_properties = <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            instance
</span></span><span style=display:flex><span>                .enumerate_device_extension_properties(*device)
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> device_extension <span style=font-weight:700>in</span> DEVICE_EXTENSIONS {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> extension_properties
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .find(|extension_property| <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                    &amp;CStr::from_ptr(extension_property.extension_name.as_ptr())
</span></span><span style=display:flex><span>                        .to_str()
</span></span><span style=display:flex><span>                        .unwrap()
</span></span><span style=display:flex><span>                        == &amp;CStr::from_ptr(*device_extension).to_str().unwrap()
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .is_none()
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> <span style=font-weight:700>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Of course, this just tells us that the extension is supported. We still need to actually enable it. That, at least, is simple: we just need to update our logical device creation.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>        <span style=font-weight:700>let</span> device_create_info = vk::DeviceCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DEVICE_CREATE_INFO,
</span></span><span style=display:flex><span>            queue_create_info_count: <span style=font-weight:700>device_queue_create_infos</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            p_queue_create_infos: <span style=font-weight:700>device_queue_create_infos</span>.as_ptr(),
</span></span><span style=display:flex><span>            p_enabled_features: <span>&amp;</span><span style=font-weight:700>device_features</span>,
</span></span><span style=display:flex><span>            enabled_layer_count: <span style=font-weight:700>VALIDATION_LAYERS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_layer_names: <span style=font-weight:700>VALIDATION_LAYERS</span>.as_ptr(),
</span></span><span style=display:flex><span>            enabled_extension_count: <span style=font-weight:700>DEVICE_EXTENSIONS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_extension_names: <span style=font-weight:700>DEVICE_EXTENSIONS</span>.as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span></code></pre></div><p>That&rsquo;s all nice and straightforward, but there&rsquo;s still a ton of properties beyond this we need to verify for our swap chain. We&rsquo;ll keep the details tightly bound in a struct:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>struct</span> <span style=font-weight:700>swap_chain_support_details</span> {
</span></span><span style=display:flex><span>    capabilities: <span style=font-weight:700>vk</span>::SurfaceCapabilitiesKHR,
</span></span><span style=display:flex><span>    formats: Vec&lt;vk::SurfaceFormatKHR&gt;,
</span></span><span style=display:flex><span>    present_modes: Vec&lt;vk::PresentModeKHR&gt;,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since we&rsquo;re trying to at least be slightly idomatic here, we can just handle our populating this struct with <code>new</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>impl</span> swap_chain_support_details {
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry, instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance, device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice, surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR) -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface_interface = Surface::new(entry, instance);
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            capabilities: <span style=font-weight:700>unsafe</span> { surface_interface.get_physical_device_surface_capabilities(*device, *surface).unwrap() },
</span></span><span style=display:flex><span>            formats: <span style=font-weight:700>unsafe</span> { surface_interface.get_physical_device_surface_formats(*device, *surface).unwrap() },
</span></span><span style=display:flex><span>            present_modes: <span style=font-weight:700>unsafe</span> { surface_interface.get_physical_device_surface_present_modes(*device, *surface).unwrap() },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And with that, our <code>is_device_suitable</code> grows yet again:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> is_device_suitable(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span>bool</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_index, present_queue_index) =
</span></span><span style=display:flex><span>            VulkanDetails::find_queue_familes(entry, instance, device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> swap_chain_support = swap_chain_support_details::new(entry, instance, device, surface);
</span></span><span style=display:flex><span>        graphics_queue_index.is_some()
</span></span><span style=display:flex><span>            &amp;&amp; present_queue_index.is_some()
</span></span><span style=display:flex><span>            &amp;&amp; VulkanDetails::check_device_extension_support(instance, device)
</span></span><span style=display:flex><span>            &amp;&amp; !swap_chain_support.formats.is_empty()
</span></span><span style=display:flex><span>            &amp;&amp; !swap_chain_support.present_modes.is_empty()
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>That gives us the formats and the modes, but we still need to figure out the right settings for the swap chain such as the surface format, presentation mode, and swap extent. This means, of course, a new member to our <code>vulkan_details</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    present_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    swap_chain: <span style=font-weight:700>vk</span>::SwapchainKHR,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, we need functions to evaluate the best of what we can get out of our swap chain support details. Here we strictly match the tutorial:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> choose_swap_surface_format(formats: Vec&lt;vk::SurfaceFormatKHR&gt;) -&gt; <span style=font-weight:700>vk</span>::SurfaceFormatKHR {
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> available_format <span style=font-weight:700>in</span> &amp;formats {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> available_format.format == vk::Format::B8G8R8A8_SRGB &amp;&amp; available_format.color_space == vk::ColorSpaceKHR::SRGB_NONLINEAR {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> *available_format;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        formats[0]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> choose_swap_present_mode(present_modes: Vec&lt;vk::PresentModeKHR&gt;) -&gt; <span style=font-weight:700>vk</span>::PresentModeKHR {
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> available_present_mode <span style=font-weight:700>in</span> present_modes {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> available_present_mode == vk::PresentModeKHR::MAILBOX {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> available_present_mode;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        vk::PresentModeKHR::FIFO
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> choose_swap_extent(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window, capabilities: <span style=font-weight:700>vk</span>::SurfaceCapabilitiesKHR) -&gt; <span style=font-weight:700>vk</span>::Extent2D {
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> capabilities.current_extent.width != <span>u32</span>::MAX {
</span></span><span style=display:flex><span>            capabilities.current_extent
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> window_size = window.inner_size();
</span></span><span style=display:flex><span>            vk::Extent2D {
</span></span><span style=display:flex><span>                width: <span style=font-weight:700>window_size</span>.width.clamp(capabilities.min_image_extent.width, capabilities.max_image_extent.width),
</span></span><span style=display:flex><span>                height: <span style=font-weight:700>window_size</span>.height.clamp(capabilities.min_image_extent.height, capabilities.max_image_extent.height),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Similarly for building our swapchain:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_swap_chain(
</span></span><span style=display:flex><span>        window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window,
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        physical_device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::SwapchainKHR {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> swap_chain_support =
</span></span><span style=display:flex><span>            SwapchainSupportDetails::new(entry, instance, physical_device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> format = VulkanDetails::choose_swap_surface_format(swap_chain_support.formats);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> present_mode =
</span></span><span style=display:flex><span>            VulkanDetails::choose_swap_present_mode(swap_chain_support.present_modes);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> image_count = {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> swap_chain_support.capabilities.max_image_count &gt; 0
</span></span><span style=display:flex><span>                &amp;&amp; swap_chain_support.capabilities.min_image_count
</span></span><span style=display:flex><span>                    &gt; swap_chain_support.capabilities.max_image_count
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                swap_chain_support.capabilities.max_image_count
</span></span><span style=display:flex><span>            } <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>                swap_chain_support.capabilities.min_image_count + 1
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> extent = VulkanDetails::choose_swap_extent(window, &amp;swap_chain_support.capabilities);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_index, present_mode_index) =
</span></span><span style=display:flex><span>            VulkanDetails::find_queue_familes(entry, instance, physical_device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> queue_index_equivalent = graphics_queue_index.unwrap() == present_mode_index.unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> queue_family_indices = vec![graphics_queue_index.unwrap(), present_mode_index.unwrap()];
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> create_info = vk::SwapchainCreateInfoKHR {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::SWAPCHAIN_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>            surface: *surface,
</span></span><span style=display:flex><span>            min_image_count: <span style=font-weight:700>image_count</span>,
</span></span><span style=display:flex><span>            image_format: <span style=font-weight:700>format</span>.format,
</span></span><span style=display:flex><span>            image_color_space: <span style=font-weight:700>format</span>.color_space,
</span></span><span style=display:flex><span>            image_extent: <span style=font-weight:700>extent</span>,
</span></span><span style=display:flex><span>            image_array_layers: 1,
</span></span><span style=display:flex><span>            image_usage: <span style=font-weight:700>vk</span>::ImageUsageFlags::COLOR_ATTACHMENT,
</span></span><span style=display:flex><span>            image_sharing_mode: <span style=font-weight:700>if</span> queue_index_equivalent {
</span></span><span style=display:flex><span>                vk::SharingMode::EXCLUSIVE
</span></span><span style=display:flex><span>            } <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>                vk::SharingMode::CONCURRENT
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            queue_family_index_count: <span style=font-weight:700>if</span> queue_index_equivalent { 0 } <span style=font-weight:700>else</span> { 2 },
</span></span><span style=display:flex><span>            p_queue_family_indices: <span style=font-weight:700>if</span> queue_index_equivalent {
</span></span><span style=display:flex><span>                ptr::null()
</span></span><span style=display:flex><span>            } <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>                queue_family_indices.as_ptr() <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> <span>u32</span>
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            pre_transform: <span style=font-weight:700>swap_chain_support</span>.capabilities.current_transform,
</span></span><span style=display:flex><span>            composite_alpha: <span style=font-weight:700>vk</span>::CompositeAlphaFlagsKHR::OPAQUE,
</span></span><span style=display:flex><span>            present_mode: <span style=font-weight:700>present_mode</span>,
</span></span><span style=display:flex><span>            clipped: <span style=font-weight:700>vk</span>::TRUE,
</span></span><span style=display:flex><span>            old_swapchain: <span style=font-weight:700>vk</span>::SwapchainKHR::null(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            Swapchain::new(instance, device)
</span></span><span style=display:flex><span>                .create_swapchain(&amp;create_info, None)
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            Swapchain::new(&amp;self.instance, &amp;self.device).destroy_swapchain(self.swap_chain, None);
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance)
</span></span><span style=display:flex><span>                .destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(&amp;self.entry, &amp;self.instance).destroy_surface(self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>That handles the swapchain! Now we need to set up actually pulling images out of it, and setting up some additional data entries in our overall struct, leaving us with this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::ext::DebugUtils;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::khr::Surface;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::khr::Swapchain;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::extensions::khr::{AndroidSurface, WaylandSurface, Win32Surface, XcbSurface, XlibSurface};
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::prelude::*;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> ash::{vk, Entry};
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> raw_window_handle::HasRawWindowHandle;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> std::collections::HashSet;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> std::ffi::c_void;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> std::ffi::CStr;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> std::ptr;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> std::vec::Vec;
</span></span><span style=display:flex><span><span style=font-weight:700>use</span> winit::{
</span></span><span style=display:flex><span>    dpi::PhysicalSize,
</span></span><span style=display:flex><span>    event::{Event, WindowEvent},
</span></span><span style=display:flex><span>    event_loop::{ControlFlow, EventLoop},
</span></span><span style=display:flex><span>    window::WindowBuilder,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> WIDTH: <span>u32</span> = 800;
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> HEIGHT: <span>u32</span> = 600;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> VALIDATION_LAYERS: <span>&amp;</span>[*<span style=font-weight:700>const</span> <span>i8</span>] = &amp;[<span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>    CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;VK_LAYER_KHRONOS_validation\0&#34;</span>.as_bytes()).as_ptr()
</span></span><span style=display:flex><span>}];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> DEVICE_EXTENSIONS: <span>&amp;</span>[*<span style=font-weight:700>const</span> <span>i8</span>] =
</span></span><span style=display:flex><span>    &amp;[<span style=font-weight:700>unsafe</span> { CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;VK_KHR_swapchain\0&#34;</span>.as_bytes()).as_ptr() }];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> REQUIRED_EXTENSIONS: <span>&amp;</span>[*<span style=font-weight:700>const</span> <span>i8</span>] = &amp;[
</span></span><span style=display:flex><span>    Surface::name().as_ptr(),
</span></span><span style=display:flex><span>    Win32Surface::name().as_ptr(),
</span></span><span style=display:flex><span>    DebugUtils::name().as_ptr(),
</span></span><span style=display:flex><span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>extern</span> <span style=font-style:italic>&#34;system&#34;</span> <span style=font-weight:700>fn</span> debug_callback(
</span></span><span style=display:flex><span>    _message_severity: <span style=font-weight:700>vk</span>::DebugUtilsMessageSeverityFlagsEXT,
</span></span><span style=display:flex><span>    _message_type: <span style=font-weight:700>vk</span>::DebugUtilsMessageTypeFlagsEXT,
</span></span><span style=display:flex><span>    callback_data: *<span style=font-weight:700>const</span> vk::DebugUtilsMessengerCallbackDataEXT,
</span></span><span style=display:flex><span>    _: *<span style=font-weight:700>mut</span> c_void,
</span></span><span style=display:flex><span>) -&gt; <span style=font-weight:700>vk</span>::Bool32 {
</span></span><span style=display:flex><span>    print!(<span style=font-style:italic>&#34;validation layer: {}&#34;</span>, <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>        CStr::from_ptr((*callback_data).p_message).to_str().unwrap()
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    vk::FALSE
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>struct</span> <span style=font-weight:700>SwapchainSupportDetails</span> {
</span></span><span style=display:flex><span>    capabilities: <span style=font-weight:700>vk</span>::SurfaceCapabilitiesKHR,
</span></span><span style=display:flex><span>    formats: Vec&lt;vk::SurfaceFormatKHR&gt;,
</span></span><span style=display:flex><span>    present_modes: Vec&lt;vk::PresentModeKHR&gt;,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> SwapchainSupportDetails {
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface_interface = Surface::new(entry, instance);
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            capabilities: <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                surface_interface
</span></span><span style=display:flex><span>                    .get_physical_device_surface_capabilities(*device, *surface)
</span></span><span style=display:flex><span>                    .unwrap()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            formats: <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                surface_interface
</span></span><span style=display:flex><span>                    .get_physical_device_surface_formats(*device, *surface)
</span></span><span style=display:flex><span>                    .unwrap()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            present_modes: <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                surface_interface
</span></span><span style=display:flex><span>                    .get_physical_device_surface_present_modes(*device, *surface)
</span></span><span style=display:flex><span>                    .unwrap()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    present_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    swap_chain: <span style=font-weight:700>vk</span>::SwapchainKHR,
</span></span><span style=display:flex><span>    swap_chain_images: Vec&lt;vk::Image&gt;,
</span></span><span style=display:flex><span>    swap_chain_image_format: <span style=font-weight:700>vk</span>::Format,
</span></span><span style=display:flex><span>    swap_chain_extent: <span style=font-weight:700>vk</span>::Extent2D,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>HelloTriangleApplication</span> {
</span></span><span style=display:flex><span>    event_loop: <span style=font-weight:700>winit</span>::event_loop::EventLoop&lt;()&gt;,
</span></span><span style=display:flex><span>    window: <span style=font-weight:700>winit</span>::window::Window,
</span></span><span style=display:flex><span>    vulkan_details: <span style=font-weight:700>VulkanDetails</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> VulkanDetails {
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new(window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (
</span></span><span style=display:flex><span>            entry,
</span></span><span style=display:flex><span>            instance,
</span></span><span style=display:flex><span>            debug_messenger,
</span></span><span style=display:flex><span>            surface,
</span></span><span style=display:flex><span>            physical_device,
</span></span><span style=display:flex><span>            device,
</span></span><span style=display:flex><span>            graphics_queue,
</span></span><span style=display:flex><span>            present_queue,
</span></span><span style=display:flex><span>            swap_chain,
</span></span><span style=display:flex><span>            swap_chain_images,
</span></span><span style=display:flex><span>            swap_chain_image_format,
</span></span><span style=display:flex><span>            swap_chain_extent,
</span></span><span style=display:flex><span>        ) = VulkanDetails::init_vulkan(&amp;window);
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            entry: <span style=font-weight:700>entry</span>,
</span></span><span style=display:flex><span>            instance: <span style=font-weight:700>instance</span>,
</span></span><span style=display:flex><span>            debug_messenger: <span style=font-weight:700>debug_messenger</span>,
</span></span><span style=display:flex><span>            surface: <span style=font-weight:700>surface</span>,
</span></span><span style=display:flex><span>            physical_device: <span style=font-weight:700>physical_device</span>,
</span></span><span style=display:flex><span>            device: <span style=font-weight:700>device</span>,
</span></span><span style=display:flex><span>            graphics_queue: <span style=font-weight:700>graphics_queue</span>,
</span></span><span style=display:flex><span>            present_queue: <span style=font-weight:700>present_queue</span>,
</span></span><span style=display:flex><span>            swap_chain: <span style=font-weight:700>swap_chain</span>,
</span></span><span style=display:flex><span>            swap_chain_images: <span style=font-weight:700>swap_chain_images</span>,
</span></span><span style=display:flex><span>            swap_chain_image_format: <span style=font-weight:700>swap_chain_image_format</span>,
</span></span><span style=display:flex><span>            swap_chain_extent: <span style=font-weight:700>swap_chain_extent</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_vulkan(
</span></span><span style=display:flex><span>        window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window,
</span></span><span style=display:flex><span>    ) -&gt; (
</span></span><span style=display:flex><span>        ash::Entry,
</span></span><span style=display:flex><span>        ash::Instance,
</span></span><span style=display:flex><span>        vk::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>        vk::SurfaceKHR,
</span></span><span style=display:flex><span>        vk::PhysicalDevice,
</span></span><span style=display:flex><span>        ash::Device,
</span></span><span style=display:flex><span>        vk::Queue,
</span></span><span style=display:flex><span>        vk::Queue,
</span></span><span style=display:flex><span>        vk::SwapchainKHR,
</span></span><span style=display:flex><span>        Vec&lt;vk::Image&gt;,
</span></span><span style=display:flex><span>        vk::Format,
</span></span><span style=display:flex><span>        vk::Extent2D,
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> entry = Entry::linked();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> instance = VulkanDetails::create_instance(&amp;entry).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> debug_messenger = VulkanDetails::create_debug_messenger(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface = VulkanDetails::create_surface(&amp;window, &amp;entry, &amp;instance).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> physical_device =
</span></span><span style=display:flex><span>            VulkanDetails::pick_physical_device(&amp;entry, &amp;instance, &amp;surface).unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device =
</span></span><span style=display:flex><span>            VulkanDetails::create_logical_device(&amp;entry, &amp;instance, &amp;physical_device, &amp;surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_index, present_queue_index) =
</span></span><span style=display:flex><span>            VulkanDetails::find_queue_familes(&amp;entry, &amp;instance, &amp;physical_device, &amp;surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> graphics_queue =
</span></span><span style=display:flex><span>            <span style=font-weight:700>unsafe</span> { device.get_device_queue(graphics_queue_index.unwrap() <span style=font-weight:700>as</span> <span>u32</span>, 0) };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> present_queue =
</span></span><span style=display:flex><span>            <span style=font-weight:700>unsafe</span> { device.get_device_queue(present_queue_index.unwrap() <span style=font-weight:700>as</span> <span>u32</span>, 0) };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (swap_chain, swap_chain_images, swap_chain_format, swap_chain_extent) =
</span></span><span style=display:flex><span>            VulkanDetails::create_swap_chain(
</span></span><span style=display:flex><span>                window,
</span></span><span style=display:flex><span>                &amp;entry,
</span></span><span style=display:flex><span>                &amp;instance,
</span></span><span style=display:flex><span>                &amp;physical_device,
</span></span><span style=display:flex><span>                &amp;device,
</span></span><span style=display:flex><span>                &amp;surface,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            entry,
</span></span><span style=display:flex><span>            instance,
</span></span><span style=display:flex><span>            debug_messenger,
</span></span><span style=display:flex><span>            surface,
</span></span><span style=display:flex><span>            physical_device,
</span></span><span style=display:flex><span>            device,
</span></span><span style=display:flex><span>            graphics_queue,
</span></span><span style=display:flex><span>            present_queue,
</span></span><span style=display:flex><span>            swap_chain,
</span></span><span style=display:flex><span>            swap_chain_images,
</span></span><span style=display:flex><span>            swap_chain_format,
</span></span><span style=display:flex><span>            swap_chain_extent,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_instance(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry) -&gt; <span style=font-weight:700>VkResult</span>&lt;ash::Instance&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> !VulkanDetails::check_validation_layer_support(&amp;entry) {
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> Err(vk::Result::ERROR_INITIALIZATION_FAILED);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> app_info = vk::ApplicationInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::APPLICATION_INFO,
</span></span><span style=display:flex><span>            p_application_name: <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;Hello Triangle\0&#34;</span>.as_bytes()).as_ptr()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            application_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            p_engine_name: <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                CStr::from_bytes_with_nul_unchecked(<span style=font-style:italic>&#34;No Engine\0&#34;</span>.as_bytes()).as_ptr()
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            engine_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            api_version: <span style=font-weight:700>vk</span>::make_api_version(0, 1, 0, 0),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> create_info = vk::InstanceCreateInfo {
</span></span><span style=display:flex><span>            p_application_info: <span>&amp;</span><span style=font-weight:700>app_info</span>,
</span></span><span style=display:flex><span>            enabled_layer_count: <span style=font-weight:700>VALIDATION_LAYERS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_layer_names: <span style=font-weight:700>VALIDATION_LAYERS</span>.as_ptr(),
</span></span><span style=display:flex><span>            enabled_extension_count: <span style=font-weight:700>REQUIRED_EXTENSIONS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_extension_names: <span style=font-weight:700>REQUIRED_EXTENSIONS</span>.as_ptr(),
</span></span><span style=display:flex><span>            p_next: <span>&amp;</span><span style=font-weight:700>VulkanDetails</span>::populate_debug_messenger_create_info() <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> _
</span></span><span style=display:flex><span>                <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> c_void,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { entry.create_instance(&amp;create_info, None) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> check_validation_layer_support(entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry) -&gt; <span>bool</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> layer_properties = entry.enumerate_instance_layer_properties().unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> layer <span style=font-weight:700>in</span> VALIDATION_LAYERS {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> <span style=font-weight:700>let</span> None = layer_properties.iter().find(|l| {
</span></span><span style=display:flex><span>                <span style=font-style:italic>// This horrible construction is because Vulkan operates with C strings and Rust does not
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>                <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                    &amp;CStr::from_ptr(l.layer_name.as_ptr()).to_str().unwrap()
</span></span><span style=display:flex><span>                        == &amp;CStr::from_ptr(*layer).to_str().unwrap()
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }) {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> <span style=font-weight:700>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_debug_messenger(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;entry, &amp;instance)
</span></span><span style=display:flex><span>                .create_debug_utils_messenger(
</span></span><span style=display:flex><span>                    &amp;VulkanDetails::populate_debug_messenger_create_info(),
</span></span><span style=display:flex><span>                    None,
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_surface(
</span></span><span style=display:flex><span>        window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window,
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>VkResult</span>&lt;vk::SurfaceKHR&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>match</span> window.raw_window_handle() {
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::AndroidNdk(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::AndroidSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::ANDROID_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.a_native_window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> android_surface = AndroidSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { android_surface.create_android_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Win32(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::Win32SurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::WIN32_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    hwnd: <span style=font-weight:700>handle</span>.hwnd,
</span></span><span style=display:flex><span>                    hinstance: <span style=font-weight:700>handle</span>.hinstance,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> win32_surface = Win32Surface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { win32_surface.create_win32_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Wayland(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::WaylandSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::WAYLAND_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    display: <span style=font-weight:700>handle</span>.surface,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> wayland_surface = WaylandSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { wayland_surface.create_wayland_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Xcb(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::XcbSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::XCB_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> xcb_surface = XcbSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { xcb_surface.create_xcb_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            raw_window_handle::RawWindowHandle::Xlib(handle) =&gt; {
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> surface_create_info = vk::XlibSurfaceCreateInfoKHR {
</span></span><span style=display:flex><span>                    s_type: <span style=font-weight:700>vk</span>::StructureType::XLIB_SURFACE_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>                    window: <span style=font-weight:700>handle</span>.window,
</span></span><span style=display:flex><span>                    ..Default::default()
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                <span style=font-weight:700>let</span> xlib_surface = XlibSurface::new(&amp;entry, &amp;instance);
</span></span><span style=display:flex><span>                <span style=font-weight:700>unsafe</span> { xlib_surface.create_xlib_surface(&amp;surface_create_info, None) }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            _ =&gt; Err(vk::Result::ERROR_INITIALIZATION_FAILED),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> populate_debug_messenger_create_info() -&gt; <span style=font-weight:700>vk</span>::DebugUtilsMessengerCreateInfoEXT {
</span></span><span style=display:flex><span>        vk::DebugUtilsMessengerCreateInfoEXT {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
</span></span><span style=display:flex><span>            message_severity: <span style=font-weight:700>vk</span>::DebugUtilsMessageSeverityFlagsEXT::VERBOSE
</span></span><span style=display:flex><span>                | vk::DebugUtilsMessageSeverityFlagsEXT::WARNING
</span></span><span style=display:flex><span>                | vk::DebugUtilsMessageSeverityFlagsEXT::ERROR,
</span></span><span style=display:flex><span>            message_type: <span style=font-weight:700>vk</span>::DebugUtilsMessageTypeFlagsEXT::GENERAL
</span></span><span style=display:flex><span>                | vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION
</span></span><span style=display:flex><span>                | vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
</span></span><span style=display:flex><span>            pfn_user_callback: Some(debug_callback),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> pick_physical_device(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>VkResult</span>&lt;vk::PhysicalDevice&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> physical_device: Option&lt;vk::PhysicalDevice&gt; = None;
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> devices = <span style=font-weight:700>unsafe</span> { instance.enumerate_physical_devices().unwrap() };
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> devices.len() == 0 {
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> Err(vk::Result::ERROR_INITIALIZATION_FAILED);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> device <span style=font-weight:700>in</span> devices {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> VulkanDetails::is_device_suitable(entry, instance, &amp;device, surface) {
</span></span><span style=display:flex><span>                physical_device = Some(device);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        physical_device.ok_or(vk::Result::ERROR_INITIALIZATION_FAILED)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> is_device_suitable(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span>bool</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_index, present_queue_index) =
</span></span><span style=display:flex><span>            VulkanDetails::find_queue_familes(entry, instance, device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> swap_chain_support = SwapchainSupportDetails::new(entry, instance, device, surface);
</span></span><span style=display:flex><span>        graphics_queue_index.is_some()
</span></span><span style=display:flex><span>            &amp;&amp; present_queue_index.is_some()
</span></span><span style=display:flex><span>            &amp;&amp; VulkanDetails::check_device_extension_support(instance, device)
</span></span><span style=display:flex><span>            &amp;&amp; !swap_chain_support.formats.is_empty()
</span></span><span style=display:flex><span>            &amp;&amp; !swap_chain_support.present_modes.is_empty()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> check_device_extension_support(
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    ) -&gt; <span>bool</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> extension_properties = <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            instance
</span></span><span style=display:flex><span>                .enumerate_device_extension_properties(*device)
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> device_extension <span style=font-weight:700>in</span> DEVICE_EXTENSIONS {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> extension_properties
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .find(|extension_property| <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                    &amp;CStr::from_ptr(extension_property.extension_name.as_ptr())
</span></span><span style=display:flex><span>                        .to_str()
</span></span><span style=display:flex><span>                        .unwrap()
</span></span><span style=display:flex><span>                        == &amp;CStr::from_ptr(*device_extension).to_str().unwrap()
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .is_none()
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> <span style=font-weight:700>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> find_queue_familes(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; (Option&lt;<span>usize</span>&gt;, Option&lt;<span>usize</span>&gt;) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> queue_family_properties =
</span></span><span style=display:flex><span>            <span style=font-weight:700>unsafe</span> { instance.get_physical_device_queue_family_properties(*device) };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> surface_details = Surface::new(entry, instance);
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            queue_family_properties.iter().position(|&amp;queue_family| {
</span></span><span style=display:flex><span>                queue_family.queue_flags &amp; vk::QueueFlags::GRAPHICS == vk::QueueFlags::GRAPHICS
</span></span><span style=display:flex><span>            }),
</span></span><span style=display:flex><span>            queue_family_properties
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .enumerate()
</span></span><span style=display:flex><span>                .position(|(index, _)| <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>                    surface_details
</span></span><span style=display:flex><span>                        .get_physical_device_surface_support(*device, index <span style=font-weight:700>as</span> <span>u32</span>, *surface)
</span></span><span style=display:flex><span>                        .unwrap()
</span></span><span style=display:flex><span>                }),
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_logical_device(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        physical_device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>ash</span>::Device {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (gq, pq) = VulkanDetails::find_queue_familes(entry, instance, physical_device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> queues = HashSet::new();
</span></span><span style=display:flex><span>        queues.insert(gq.unwrap() <span style=font-weight:700>as</span> <span>u32</span>);
</span></span><span style=display:flex><span>        queues.insert(pq.unwrap() <span style=font-weight:700>as</span> <span>u32</span>);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> device_queue_create_infos = Vec::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> queue <span style=font-weight:700>in</span> queues {
</span></span><span style=display:flex><span>            device_queue_create_infos.push(vk::DeviceQueueCreateInfo {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::DEVICE_QUEUE_CREATE_INFO,
</span></span><span style=display:flex><span>                queue_family_index: <span style=font-weight:700>queue</span>,
</span></span><span style=display:flex><span>                queue_count: 1,
</span></span><span style=display:flex><span>                p_queue_priorities: <span>&amp;</span>1.0,
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device_features = vk::PhysicalDeviceFeatures {
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> device_create_info = vk::DeviceCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::DEVICE_CREATE_INFO,
</span></span><span style=display:flex><span>            queue_create_info_count: <span style=font-weight:700>device_queue_create_infos</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            p_queue_create_infos: <span style=font-weight:700>device_queue_create_infos</span>.as_ptr(),
</span></span><span style=display:flex><span>            p_enabled_features: <span>&amp;</span><span style=font-weight:700>device_features</span>,
</span></span><span style=display:flex><span>            enabled_layer_count: <span style=font-weight:700>VALIDATION_LAYERS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_layer_names: <span style=font-weight:700>VALIDATION_LAYERS</span>.as_ptr(),
</span></span><span style=display:flex><span>            enabled_extension_count: <span style=font-weight:700>DEVICE_EXTENSIONS</span>.len() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            pp_enabled_extension_names: <span style=font-weight:700>DEVICE_EXTENSIONS</span>.as_ptr(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            instance
</span></span><span style=display:flex><span>                .create_device(*physical_device, &amp;device_create_info, None)
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_swap_chain(
</span></span><span style=display:flex><span>        window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window,
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        physical_device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; (vk::SwapchainKHR, Vec&lt;vk::Image&gt;, vk::Format, vk::Extent2D) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> swap_chain_support =
</span></span><span style=display:flex><span>            SwapchainSupportDetails::new(entry, instance, physical_device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> format = VulkanDetails::choose_swap_surface_format(swap_chain_support.formats);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> present_mode =
</span></span><span style=display:flex><span>            VulkanDetails::choose_swap_present_mode(swap_chain_support.present_modes);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> image_count = {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> swap_chain_support.capabilities.max_image_count &gt; 0
</span></span><span style=display:flex><span>                &amp;&amp; swap_chain_support.capabilities.min_image_count
</span></span><span style=display:flex><span>                    &gt; swap_chain_support.capabilities.max_image_count
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                swap_chain_support.capabilities.max_image_count
</span></span><span style=display:flex><span>            } <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>                swap_chain_support.capabilities.min_image_count + 1
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> extent = VulkanDetails::choose_swap_extent(window, &amp;swap_chain_support.capabilities);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_index, present_mode_index) =
</span></span><span style=display:flex><span>            VulkanDetails::find_queue_familes(entry, instance, physical_device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> queue_index_equivalent = graphics_queue_index.unwrap() == present_mode_index.unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> queue_family_indices = vec![graphics_queue_index.unwrap(), present_mode_index.unwrap()];
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> create_info = vk::SwapchainCreateInfoKHR {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::SWAPCHAIN_CREATE_INFO_KHR,
</span></span><span style=display:flex><span>            surface: *surface,
</span></span><span style=display:flex><span>            min_image_count: <span style=font-weight:700>image_count</span>,
</span></span><span style=display:flex><span>            image_format: <span style=font-weight:700>format</span>.format,
</span></span><span style=display:flex><span>            image_color_space: <span style=font-weight:700>format</span>.color_space,
</span></span><span style=display:flex><span>            image_extent: <span style=font-weight:700>extent</span>,
</span></span><span style=display:flex><span>            image_array_layers: 1,
</span></span><span style=display:flex><span>            image_usage: <span style=font-weight:700>vk</span>::ImageUsageFlags::COLOR_ATTACHMENT,
</span></span><span style=display:flex><span>            image_sharing_mode: <span style=font-weight:700>if</span> queue_index_equivalent {
</span></span><span style=display:flex><span>                vk::SharingMode::EXCLUSIVE
</span></span><span style=display:flex><span>            } <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>                vk::SharingMode::CONCURRENT
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            queue_family_index_count: <span style=font-weight:700>if</span> queue_index_equivalent { 0 } <span style=font-weight:700>else</span> { 2 },
</span></span><span style=display:flex><span>            p_queue_family_indices: <span style=font-weight:700>if</span> queue_index_equivalent {
</span></span><span style=display:flex><span>                ptr::null()
</span></span><span style=display:flex><span>            } <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>                queue_family_indices.as_ptr() <span style=font-weight:700>as</span> *<span style=font-weight:700>const</span> <span>u32</span>
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            pre_transform: <span style=font-weight:700>swap_chain_support</span>.capabilities.current_transform,
</span></span><span style=display:flex><span>            composite_alpha: <span style=font-weight:700>vk</span>::CompositeAlphaFlagsKHR::OPAQUE,
</span></span><span style=display:flex><span>            present_mode: <span style=font-weight:700>present_mode</span>,
</span></span><span style=display:flex><span>            clipped: <span style=font-weight:700>vk</span>::TRUE,
</span></span><span style=display:flex><span>            old_swapchain: <span style=font-weight:700>vk</span>::SwapchainKHR::null(),
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> swap_chain_handle = Swapchain::new(instance, device);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> swap_chain = <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            swap_chain_handle
</span></span><span style=display:flex><span>                .create_swapchain(&amp;create_info, None)
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> swap_chain_images =
</span></span><span style=display:flex><span>            <span style=font-weight:700>unsafe</span> { swap_chain_handle.get_swapchain_images(swap_chain).unwrap() };
</span></span><span style=display:flex><span>        (swap_chain, swap_chain_images, format.format, extent)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> choose_swap_surface_format(formats: Vec&lt;vk::SurfaceFormatKHR&gt;) -&gt; <span style=font-weight:700>vk</span>::SurfaceFormatKHR {
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> available_format <span style=font-weight:700>in</span> &amp;formats {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> available_format.format == vk::Format::B8G8R8A8_SRGB
</span></span><span style=display:flex><span>                &amp;&amp; available_format.color_space == vk::ColorSpaceKHR::SRGB_NONLINEAR
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> *available_format;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        formats[0]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> choose_swap_present_mode(present_modes: Vec&lt;vk::PresentModeKHR&gt;) -&gt; <span style=font-weight:700>vk</span>::PresentModeKHR {
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> available_present_mode <span style=font-weight:700>in</span> present_modes {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> available_present_mode == vk::PresentModeKHR::MAILBOX {
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> available_present_mode;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        vk::PresentModeKHR::FIFO
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> choose_swap_extent(
</span></span><span style=display:flex><span>        window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window,
</span></span><span style=display:flex><span>        capabilities: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceCapabilitiesKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::Extent2D {
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> capabilities.current_extent.width != <span>u32</span>::MAX {
</span></span><span style=display:flex><span>            capabilities.current_extent
</span></span><span style=display:flex><span>        } <span style=font-weight:700>else</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> window_size = window.inner_size();
</span></span><span style=display:flex><span>            vk::Extent2D {
</span></span><span style=display:flex><span>                width: <span style=font-weight:700>window_size</span>.width.clamp(
</span></span><span style=display:flex><span>                    capabilities.min_image_extent.width,
</span></span><span style=display:flex><span>                    capabilities.max_image_extent.width,
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>                height: <span style=font-weight:700>window_size</span>.height.clamp(
</span></span><span style=display:flex><span>                    capabilities.min_image_extent.height,
</span></span><span style=display:flex><span>                    capabilities.max_image_extent.height,
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            Swapchain::new(&amp;self.instance, &amp;self.device).destroy_swapchain(self.swap_chain, None);
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance)
</span></span><span style=display:flex><span>                .destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(&amp;self.entry, &amp;self.instance).destroy_surface(self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>impl</span> HelloTriangleApplication {
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> new() -&gt; <span style=font-weight:700>Self</span> {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (event_loop, window) = HelloTriangleApplication::init_window().unwrap();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> vulkan_details = VulkanDetails::new(&amp;window);
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            event_loop: <span style=font-weight:700>event_loop</span>,
</span></span><span style=display:flex><span>            window: <span style=font-weight:700>window</span>,
</span></span><span style=display:flex><span>            vulkan_details: <span style=font-weight:700>vulkan_details</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(<span style=font-weight:700>mut</span> self) -&gt; ! {
</span></span><span style=display:flex><span>        self.event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Wait;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; {
</span></span><span style=display:flex><span>                    self.vulkan_details.cleanup();
</span></span><span style=display:flex><span>                    *control_flow = ControlFlow::Exit
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _ =&gt; (),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> init_window(
</span></span><span style=display:flex><span>    ) -&gt; Result&lt;(winit::event_loop::EventLoop&lt;()&gt;, winit::window::Window), winit::error::OsError&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> event_loop = EventLoop::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> window = WindowBuilder::new()
</span></span><span style=display:flex><span>            .with_resizable(<span style=font-weight:700>false</span>)
</span></span><span style=display:flex><span>            .with_inner_size(PhysicalSize::new(WIDTH, HEIGHT))
</span></span><span style=display:flex><span>            .build(&amp;event_loop)?;
</span></span><span style=display:flex><span>        Ok((event_loop, window))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Things are getting quite sizable now! But, we&rsquo;re not done yet: we need to add some image views. The struct grows once more:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    present_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    swap_chain: <span style=font-weight:700>vk</span>::SwapchainKHR,
</span></span><span style=display:flex><span>    swap_chain_images: Vec&lt;vk::Image&gt;,
</span></span><span style=display:flex><span>    swap_chain_image_format: <span style=font-weight:700>vk</span>::Format,
</span></span><span style=display:flex><span>    swap_chain_extent: <span style=font-weight:700>vk</span>::Extent2D,
</span></span><span style=display:flex><span>    swap_chain_image_views: Vec&lt;vk::ImageView&gt;,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then we construct our image view, similarly to the tutorial though as always involving a lot more passing of data around:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_image_views(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        swap_chain_images: <span>&amp;</span>Vec&lt;vk::Image&gt;,
</span></span><span style=display:flex><span>        swap_chain_image_format: <span>&amp;</span><span style=font-weight:700>vk</span>::Format,
</span></span><span style=display:flex><span>    ) -&gt; Vec&lt;vk::ImageView&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> output_vec = Vec::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> image <span style=font-weight:700>in</span> swap_chain_images {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> create_info = vk::ImageViewCreateInfo {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::IMAGE_VIEW_CREATE_INFO,
</span></span><span style=display:flex><span>                image: *image,
</span></span><span style=display:flex><span>                view_type: <span style=font-weight:700>vk</span>::ImageViewType::TYPE_2D,
</span></span><span style=display:flex><span>                format: *swap_chain_image_format,
</span></span><span style=display:flex><span>                components: <span style=font-weight:700>vk</span>::ComponentMapping {
</span></span><span style=display:flex><span>                    r: <span style=font-weight:700>vk</span>::ComponentSwizzle::IDENTITY,
</span></span><span style=display:flex><span>                    g: <span style=font-weight:700>vk</span>::ComponentSwizzle::IDENTITY,
</span></span><span style=display:flex><span>                    b: <span style=font-weight:700>vk</span>::ComponentSwizzle::IDENTITY,
</span></span><span style=display:flex><span>                    a: <span style=font-weight:700>vk</span>::ComponentSwizzle::IDENTITY,
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                subresource_range: <span style=font-weight:700>vk</span>::ImageSubresourceRange {
</span></span><span style=display:flex><span>                    aspect_mask: <span style=font-weight:700>vk</span>::ImageAspectFlags::COLOR,
</span></span><span style=display:flex><span>                    base_mip_level: 0,
</span></span><span style=display:flex><span>                    level_count: 1,
</span></span><span style=display:flex><span>                    base_array_layer: 0,
</span></span><span style=display:flex><span>                    layer_count: 1,
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=font-weight:700>unsafe</span> { output_vec.push(device.create_image_view(&amp;create_info, None).unwrap()) };
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        output_vec
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> image_view <span style=font-weight:700>in</span> &amp;self.swap_chain_image_views {
</span></span><span style=display:flex><span>                self.device.destroy_image_view(*image_view, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Swapchain::new(&amp;self.instance, &amp;self.device).destroy_swapchain(self.swap_chain, None);
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance)
</span></span><span style=display:flex><span>                .destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(&amp;self.entry, &amp;self.instance).destroy_surface(self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Throw in the call in the expected place and everything lines up perfectly. Next up is the graphics pipeline, which will be quite the adventure.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>Â©
2022
Brad Dragun (LuuBluum)
Â·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script></body></html>