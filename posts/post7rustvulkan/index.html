<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Brad Dragun (LuuBluum)"><meta name=description content="The moment of truth is here! After handling the graphics pipeline, we&rsquo;re on our way to drawing our first triangle! All of the code can be found at this repo."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Learning Vulkan with Rust, Part 7: Drawing"><meta name=twitter:description content="The moment of truth is here! After handling the graphics pipeline, we&rsquo;re on our way to drawing our first triangle! All of the code can be found at this repo."><meta property="og:title" content="Learning Vulkan with Rust, Part 7: Drawing"><meta property="og:description" content="The moment of truth is here! After handling the graphics pipeline, we&rsquo;re on our way to drawing our first triangle! All of the code can be found at this repo."><meta property="og:type" content="article"><meta property="og:url" content="https://LuuBluum.github.io/posts/post7rustvulkan/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-14T21:20:32-07:00"><meta property="article:modified_time" content="2022-08-14T21:20:32-07:00"><title>LuuBluum's Coding Blog</title><link rel=canonical href=https://LuuBluum.github.io/posts/post7rustvulkan/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css integrity="sha256-axpPvEiVW3Kup5E+Q/q+tF6LwSDaWqQbWY3TOtysS1k=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.102.3"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>LuuBluum's Coding Blog</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://LuuBluum.github.io/posts/post7rustvulkan/>Learning Vulkan with Rust, Part 7: Drawing</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-08-14T21:20:32-07:00>August 14, 2022</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
13-minute read</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/rust/>Rust</a>
<span class=separator>â€¢</span>
<a href=/categories/vulkan/>Vulkan</a></div></div></header><div><p>The moment of truth is here! After handling the <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Introduction>graphics pipeline</a>, we&rsquo;re on our way to <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Framebuffers>drawing our first triangle</a>! All of the code can be found at <a href=https://github.com/LuuBluum/Learning-Vulkan-with-Rust>this repo</a>.</p><p>This is the big moment. By the end of all of this, we will have an actual triangle appear. But, we still have a ways to go.</p><h2 id=framebuffers>Framebuffers
<a class=heading-link href=#framebuffers><i class="fa fa-link" aria-hidden=true></i></a></h2><p>We lead with <a href=https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Framebuffers>framebuffers</a>, the thing that actually holds the data on the next frame to draw. So, we need to get that set up real quick:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    present_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    swap_chain: <span style=font-weight:700>vk</span>::SwapchainKHR,
</span></span><span style=display:flex><span>    swap_chain_images: Vec&lt;vk::Image&gt;,
</span></span><span style=display:flex><span>    swap_chain_image_format: <span style=font-weight:700>vk</span>::Format,
</span></span><span style=display:flex><span>    swap_chain_extent: <span style=font-weight:700>vk</span>::Extent2D,
</span></span><span style=display:flex><span>    swap_chain_image_views: Vec&lt;vk::ImageView&gt;,
</span></span><span style=display:flex><span>    render_pass: <span style=font-weight:700>vk</span>::RenderPass,
</span></span><span style=display:flex><span>    pipeline_layout: <span style=font-weight:700>vk</span>::PipelineLayout,
</span></span><span style=display:flex><span>    graphics_pipeline: <span style=font-weight:700>vk</span>::Pipeline,
</span></span><span style=display:flex><span>    swap_chain_frame_buffers: Vec&lt;vk::Framebuffer&gt;,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our function for creating the framebuffer is a mirror of the equivalent C++:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_framebuffers(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        swap_chain_image_views: <span>&amp;</span>Vec&lt;vk::ImageView&gt;,
</span></span><span style=display:flex><span>        swap_chain_extent: <span>&amp;</span><span style=font-weight:700>vk</span>::Extent2D,
</span></span><span style=display:flex><span>        render_pass: <span>&amp;</span><span style=font-weight:700>vk</span>::RenderPass,
</span></span><span style=display:flex><span>    ) -&gt; Vec&lt;vk::Framebuffer&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> framebuffers = Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>for</span> image_view <span style=font-weight:700>in</span> swap_chain_image_views {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> framebuffer_info = vk::FramebufferCreateInfo {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::FRAMEBUFFER_CREATE_INFO,
</span></span><span style=display:flex><span>                render_pass: *render_pass,
</span></span><span style=display:flex><span>                attachment_count: 1,
</span></span><span style=display:flex><span>                p_attachments: <span style=font-weight:700>image_view</span>,
</span></span><span style=display:flex><span>                width: <span style=font-weight:700>swap_chain_extent</span>.width,
</span></span><span style=display:flex><span>                height: <span style=font-weight:700>swap_chain_extent</span>.height,
</span></span><span style=display:flex><span>                layers: 1,
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            framebuffers
</span></span><span style=display:flex><span>                .push(<span style=font-weight:700>unsafe</span> { device.create_framebuffer(&amp;framebuffer_info, None).unwrap() });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        framebuffers
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> framebuffer <span style=font-weight:700>in</span> &amp;self.swap_chain_framebuffers {
</span></span><span style=display:flex><span>                self.device.destroy_framebuffer(*framebuffer, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            self.device.destroy_pipeline(self.graphics_pipeline, None);
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .destroy_pipeline_layout(self.pipeline_layout, None);
</span></span><span style=display:flex><span>            self.device.destroy_render_pass(self.render_pass, None);
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> image_view <span style=font-weight:700>in</span> &amp;self.swap_chain_image_views {
</span></span><span style=display:flex><span>                self.device.destroy_image_view(*image_view, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Swapchain::new(&amp;self.instance, &amp;self.device).destroy_swapchain(self.swap_chain, None);
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance)
</span></span><span style=display:flex><span>                .destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(&amp;self.entry, &amp;self.instance).destroy_surface(self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Nothing really else to say about framebuffers. We create a total amount for our given number of image views and configure their size to match our swap chain, with the render pass being the one we created. Simple enough.</p><h2 id=command-buffers>Command Buffers
<a class=heading-link href=#command-buffers><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Now, the fun part. We&rsquo;re going to use <a href=https://vulkan-tutorial.com/en/Drawing_a_triangle/Drawing/Command_buffers>command buffers</a> to actually draw. But first, a command pool, to hold the memory for our command buffer:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_command_pool(
</span></span><span style=display:flex><span>        entry: <span>&amp;</span><span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>        instance: <span>&amp;</span><span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>        physical_device: <span>&amp;</span><span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        surface: <span>&amp;</span><span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::CommandPool {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> (graphics_queue_family_index, _) =
</span></span><span style=display:flex><span>            VulkanDetails::find_queue_familes(entry, instance, physical_device, surface);
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> pool_info = vk::CommandPoolCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::COMMAND_POOL_CREATE_INFO,
</span></span><span style=display:flex><span>            flags: <span style=font-weight:700>vk</span>::CommandPoolCreateFlags::RESET_COMMAND_BUFFER,
</span></span><span style=display:flex><span>            queue_family_index: <span style=font-weight:700>graphics_queue_family_index</span>.unwrap() <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { device.create_command_pool(&amp;pool_info, None).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device.destroy_command_pool(self.command_pool, None);
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> framebuffer <span style=font-weight:700>in</span> &amp;self.swap_chain_framebuffers {
</span></span><span style=display:flex><span>                self.device.destroy_framebuffer(*framebuffer, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            self.device.destroy_pipeline(self.graphics_pipeline, None);
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .destroy_pipeline_layout(self.pipeline_layout, None);
</span></span><span style=display:flex><span>            self.device.destroy_render_pass(self.render_pass, None);
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> image_view <span style=font-weight:700>in</span> &amp;self.swap_chain_image_views {
</span></span><span style=display:flex><span>                self.device.destroy_image_view(*image_view, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Swapchain::new(&amp;self.instance, &amp;self.device).destroy_swapchain(self.swap_chain, None);
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance)
</span></span><span style=display:flex><span>                .destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(&amp;self.entry, &amp;self.instance).destroy_surface(self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Nothing particularly special there. Create the necessary info struct, populate it with whatever we need, and then use our logical device to create whatever we&rsquo;re creating. Same flow as always. The command buffer follows similarly:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_command_buffer(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        command_pool: <span>&amp;</span><span style=font-weight:700>vk</span>::CommandPool,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::CommandBuffer {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> alloc_info = vk::CommandBufferAllocateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::COMMAND_BUFFER_ALLOCATE_INFO,
</span></span><span style=display:flex><span>            command_pool: *command_pool,
</span></span><span style=display:flex><span>            level: <span style=font-weight:700>vk</span>::CommandBufferLevel::PRIMARY,
</span></span><span style=display:flex><span>            command_buffer_count: 1,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { device.allocate_command_buffers(&amp;alloc_info).unwrap()[0] }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>With that, we can actually write a drawing command. For that, again our code mirros the C++ almost identically, though rather than passing in the command buffer we just grab a reference to self (why they don&rsquo;t do this in the C++ code is beyond me):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> record_command_buffer(&amp;self, image_index: <span>usize</span>) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> begin_info = vk::CommandBufferBeginInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::COMMAND_BUFFER_BEGIN_INFO,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .begin_command_buffer(self.command_buffer, &amp;begin_info)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> clear_color = vk::ClearValue {
</span></span><span style=display:flex><span>            color: <span style=font-weight:700>vk</span>::ClearColorValue {
</span></span><span style=display:flex><span>                float32: [0.0, 0.0, 0.0, 1.0],
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> render_pass_info = vk::RenderPassBeginInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::RENDER_PASS_BEGIN_INFO,
</span></span><span style=display:flex><span>            render_pass: <span style=font-weight:700>self</span>.render_pass,
</span></span><span style=display:flex><span>            framebuffer: <span style=font-weight:700>self</span>.swap_chain_framebuffers[image_index],
</span></span><span style=display:flex><span>            render_area: <span style=font-weight:700>vk</span>::Rect2D {
</span></span><span style=display:flex><span>                offset: <span style=font-weight:700>vk</span>::Offset2D { x: 0, y: 0 },
</span></span><span style=display:flex><span>                extent: <span style=font-weight:700>self</span>.swap_chain_extent,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            clear_value_count: 1,
</span></span><span style=display:flex><span>            p_clear_values: <span>&amp;</span><span style=font-weight:700>clear_color</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device.cmd_begin_render_pass(
</span></span><span style=display:flex><span>                self.command_buffer,
</span></span><span style=display:flex><span>                &amp;render_pass_info,
</span></span><span style=display:flex><span>                vk::SubpassContents::INLINE,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            self.device.cmd_bind_pipeline(
</span></span><span style=display:flex><span>                self.command_buffer,
</span></span><span style=display:flex><span>                vk::PipelineBindPoint::GRAPHICS,
</span></span><span style=display:flex><span>                self.graphics_pipeline,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> viewport = vk::Viewport {
</span></span><span style=display:flex><span>            x: 0.0,
</span></span><span style=display:flex><span>            y: 0.0,
</span></span><span style=display:flex><span>            width: <span style=font-weight:700>self</span>.swap_chain_extent.width <span style=font-weight:700>as</span> <span>f32</span>,
</span></span><span style=display:flex><span>            height: <span style=font-weight:700>self</span>.swap_chain_extent.height <span style=font-weight:700>as</span> <span>f32</span>,
</span></span><span style=display:flex><span>            min_depth: 0.0,
</span></span><span style=display:flex><span>            max_depth: 1.0,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .cmd_set_viewport(self.command_buffer, 0, &amp;[viewport]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> scissor = vk::Rect2D {
</span></span><span style=display:flex><span>            offset: <span style=font-weight:700>vk</span>::Offset2D { x: 0, y: 0 },
</span></span><span style=display:flex><span>            extent: <span style=font-weight:700>self</span>.swap_chain_extent,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .cmd_set_scissor(self.command_buffer, 0, &amp;[scissor]);
</span></span><span style=display:flex><span>            self.device.cmd_draw(self.command_buffer, 3, 1, 0, 0);
</span></span><span style=display:flex><span>            self.device.cmd_end_render_pass(self.command_buffer);
</span></span><span style=display:flex><span>            self.device.end_command_buffer(self.command_buffer).unwrap();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>That gives us drawing. Now the actual drawing loop.</p><h2 id=rendering>Rendering
<a class=heading-link href=#rendering><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Now we get to the meat of things. Our draw command was simple enough, but now we actually have to set up how we&rsquo;re going to draw. First, we modify <code>run</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(<span style=font-weight:700>mut</span> self) -&gt; ! {
</span></span><span style=display:flex><span>        self.event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Poll;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; {
</span></span><span style=display:flex><span>                    self.vulkan_details.cleanup();
</span></span><span style=display:flex><span>                    *control_flow = ControlFlow::Exit
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _ =&gt; {
</span></span><span style=display:flex><span>                    self.vulkan_details.draw_frame();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Then we need to&mldr; actually implement drawing a frame, which means dealing with synchronization. For which we get to coordinate with Vulkan synchronization objects to do. Joy. That means more to our struct:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    present_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    swap_chain: <span style=font-weight:700>vk</span>::SwapchainKHR,
</span></span><span style=display:flex><span>    swap_chain_images: Vec&lt;vk::Image&gt;,
</span></span><span style=display:flex><span>    swap_chain_image_format: <span style=font-weight:700>vk</span>::Format,
</span></span><span style=display:flex><span>    swap_chain_extent: <span style=font-weight:700>vk</span>::Extent2D,
</span></span><span style=display:flex><span>    swap_chain_image_views: Vec&lt;vk::ImageView&gt;,
</span></span><span style=display:flex><span>    render_pass: <span style=font-weight:700>vk</span>::RenderPass,
</span></span><span style=display:flex><span>    pipeline_layout: <span style=font-weight:700>vk</span>::PipelineLayout,
</span></span><span style=display:flex><span>    graphics_pipeline: <span style=font-weight:700>vk</span>::Pipeline,
</span></span><span style=display:flex><span>    swap_chain_framebuffers: Vec&lt;vk::Framebuffer&gt;,
</span></span><span style=display:flex><span>    command_pool: <span style=font-weight:700>vk</span>::CommandPool,
</span></span><span style=display:flex><span>    command_buffer: <span style=font-weight:700>vk</span>::CommandBuffer,
</span></span><span style=display:flex><span>    image_available_semaphore: <span style=font-weight:700>vk</span>::Semaphore,
</span></span><span style=display:flex><span>    render_finished_semaphore: <span style=font-weight:700>vk</span>::Semaphore,
</span></span><span style=display:flex><span>    in_flight_fence: <span style=font-weight:700>vk</span>::Fence,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our struct is looking rather sizable at this point. The creation of these objects requires yet more structure creation, though in this case they&rsquo;re all empty:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_sync_objects(device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device) -&gt; (vk::Semaphore, vk::Semaphore, vk::Fence) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> semaphore_info = vk::SemaphoreCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::SEMAPHORE_CREATE_INFO,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> fence_info = vk::FenceCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::FENCE_CREATE_INFO,
</span></span><span style=display:flex><span>            flags: <span style=font-weight:700>vk</span>::FenceCreateFlags::SIGNALED,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                device.create_semaphore(&amp;semaphore_info, None).unwrap(),
</span></span><span style=display:flex><span>                device.create_semaphore(&amp;semaphore_info, None).unwrap(),
</span></span><span style=display:flex><span>                device.create_fence(&amp;fence_info, None).unwrap(),
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>How exciting. These get destroyed at the end like everything else:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .destroy_semaphore(self.image_available_semaphore, None);
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .destroy_semaphore(self.render_finished_semaphore, None);
</span></span><span style=display:flex><span>            self.device.destroy_fence(self.in_flight_fence, None);
</span></span><span style=display:flex><span>            self.device.destroy_command_pool(self.command_pool, None);
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> framebuffer <span style=font-weight:700>in</span> &amp;self.swap_chain_framebuffers {
</span></span><span style=display:flex><span>                self.device.destroy_framebuffer(*framebuffer, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            self.device.destroy_pipeline(self.graphics_pipeline, None);
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .destroy_pipeline_layout(self.pipeline_layout, None);
</span></span><span style=display:flex><span>            self.device.destroy_render_pass(self.render_pass, None);
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> image_view <span style=font-weight:700>in</span> &amp;self.swap_chain_image_views {
</span></span><span style=display:flex><span>                self.device.destroy_image_view(*image_view, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Swapchain::new(&amp;self.instance, &amp;self.device).destroy_swapchain(self.swap_chain, None);
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance)
</span></span><span style=display:flex><span>                .destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(&amp;self.entry, &amp;self.instance).destroy_surface(self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now, on to drawing a frame. This also mirrors the C++ (since we&rsquo;re really just deferring to Vulkan for everything at this point). Honestly it&rsquo;s rather remarkable just how much of this is the same across different systems. I guess that goes to show just how much we&rsquo;re deferring to Vulkan for everything! Just like the C++, we need to update our <code>create_render_pass</code> function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_render_pass(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        swap_chain_image_format: <span>&amp;</span><span style=font-weight:700>vk</span>::Format,
</span></span><span style=display:flex><span>    ) -&gt; <span style=font-weight:700>vk</span>::RenderPass {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> color_attachment = vk::AttachmentDescription {
</span></span><span style=display:flex><span>            format: *swap_chain_image_format,
</span></span><span style=display:flex><span>            samples: <span style=font-weight:700>vk</span>::SampleCountFlags::TYPE_1,
</span></span><span style=display:flex><span>            load_op: <span style=font-weight:700>vk</span>::AttachmentLoadOp::CLEAR,
</span></span><span style=display:flex><span>            store_op: <span style=font-weight:700>vk</span>::AttachmentStoreOp::STORE,
</span></span><span style=display:flex><span>            stencil_load_op: <span style=font-weight:700>vk</span>::AttachmentLoadOp::DONT_CARE,
</span></span><span style=display:flex><span>            stencil_store_op: <span style=font-weight:700>vk</span>::AttachmentStoreOp::DONT_CARE,
</span></span><span style=display:flex><span>            initial_layout: <span style=font-weight:700>vk</span>::ImageLayout::UNDEFINED,
</span></span><span style=display:flex><span>            final_layout: <span style=font-weight:700>vk</span>::ImageLayout::PRESENT_SRC_KHR,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> color_attachment_ref = vk::AttachmentReference {
</span></span><span style=display:flex><span>            attachment: 0,
</span></span><span style=display:flex><span>            layout: <span style=font-weight:700>vk</span>::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> subpass = vk::SubpassDescription {
</span></span><span style=display:flex><span>            pipeline_bind_point: <span style=font-weight:700>vk</span>::PipelineBindPoint::GRAPHICS,
</span></span><span style=display:flex><span>            color_attachment_count: 1,
</span></span><span style=display:flex><span>            p_color_attachments: <span>&amp;</span><span style=font-weight:700>color_attachment_ref</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> dependency = vk::SubpassDependency {
</span></span><span style=display:flex><span>            src_subpass: <span style=font-weight:700>vk</span>::SUBPASS_EXTERNAL,
</span></span><span style=display:flex><span>            dst_subpass: 0,
</span></span><span style=display:flex><span>            src_stage_mask: <span style=font-weight:700>vk</span>::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT,
</span></span><span style=display:flex><span>            src_access_mask: <span style=font-weight:700>vk</span>::AccessFlags::empty(),
</span></span><span style=display:flex><span>            dst_stage_mask: <span style=font-weight:700>vk</span>::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT,
</span></span><span style=display:flex><span>            dst_access_mask: <span style=font-weight:700>vk</span>::AccessFlags::COLOR_ATTACHMENT_WRITE,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> render_pass_info = vk::RenderPassCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::RENDER_PASS_CREATE_INFO,
</span></span><span style=display:flex><span>            attachment_count: 1,
</span></span><span style=display:flex><span>            p_attachments: <span>&amp;</span><span style=font-weight:700>color_attachment</span>,
</span></span><span style=display:flex><span>            subpass_count: 1,
</span></span><span style=display:flex><span>            p_subpasses: <span>&amp;</span><span style=font-weight:700>subpass</span>,
</span></span><span style=display:flex><span>            dependency_count: 1,
</span></span><span style=display:flex><span>            p_dependencies: <span>&amp;</span><span style=font-weight:700>dependency</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { device.create_render_pass(&amp;render_pass_info, None).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Then we have our function for drawing a frame:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> draw_frame(&amp;self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .wait_for_fences(&amp;[self.in_flight_fence], <span style=font-weight:700>true</span>, <span>u64</span>::MAX)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.device.reset_fences(&amp;[self.in_flight_fence]).unwrap();
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> swap_chain_handle = Swapchain::new(&amp;self.instance, &amp;self.device);
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> (image_index, _) = swap_chain_handle
</span></span><span style=display:flex><span>                .acquire_next_image(
</span></span><span style=display:flex><span>                    self.swap_chain,
</span></span><span style=display:flex><span>                    <span>u64</span>::MAX,
</span></span><span style=display:flex><span>                    self.image_available_semaphore,
</span></span><span style=display:flex><span>                    vk::Fence::null(),
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .reset_command_buffer(self.command_buffer, vk::CommandBufferResetFlags::empty())
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.record_command_buffer(image_index <span style=font-weight:700>as</span> <span>usize</span>);
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> submit_info = vk::SubmitInfo {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::SUBMIT_INFO,
</span></span><span style=display:flex><span>                wait_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_wait_semaphores: [self.image_available_semaphore].as_ptr(),
</span></span><span style=display:flex><span>                p_wait_dst_stage_mask: [vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT].as_ptr(),
</span></span><span style=display:flex><span>                command_buffer_count: 1,
</span></span><span style=display:flex><span>                p_command_buffers: [self.command_buffer].as_ptr(),
</span></span><span style=display:flex><span>                signal_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_signal_semaphores: [self.render_finished_semaphore].as_ptr(),
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .queue_submit(self.graphics_queue, &amp;[submit_info], self.in_flight_fence)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> present_info = vk::PresentInfoKHR {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::PRESENT_INFO_KHR,
</span></span><span style=display:flex><span>                wait_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_wait_semaphores: [self.render_finished_semaphore].as_ptr(),
</span></span><span style=display:flex><span>                swapchain_count: 1,
</span></span><span style=display:flex><span>                p_swapchains: [self.swap_chain].as_ptr(),
</span></span><span style=display:flex><span>                p_image_indices: <span>&amp;</span><span style=font-weight:700>image_index</span>,
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            swap_chain_handle
</span></span><span style=display:flex><span>                .queue_present(self.present_queue, &amp;present_info)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>That leaves us with a pickle: we want to wait on destroying all of our Vulkan details until they&rsquo;re not in-use, but our current approach doesn&rsquo;t wait for the window to be destroyed. We can adjust that, though:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(<span style=font-weight:700>mut</span> self) -&gt; ! {
</span></span><span style=display:flex><span>        self.event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Poll;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; *control_flow = ControlFlow::Exit,
</span></span><span style=display:flex><span>                Event::LoopDestroyed =&gt; {
</span></span><span style=display:flex><span>                    <span style=font-weight:700>unsafe</span> { self.vulkan_details.device.device_wait_idle().unwrap() };
</span></span><span style=display:flex><span>                    self.vulkan_details.cleanup();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _ =&gt; {
</span></span><span style=display:flex><span>                    self.vulkan_details.draw_frame();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now we actually handle our cleanup on the actual destruction of the event loop, which happens after the window closes. Much better. If we put in that wait where it was before, it would never actually let the window close. We&rsquo;re not done yet, though!</p><h2 id=handling-multiple-frames>Handling Multiple Frames
<a class=heading-link href=#handling-multiple-frames><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Right now we just leave one <a href=https://vulkan-tutorial.com/en/Drawing_a_triangle/Drawing/Frames_in_flight>frame in flight</a>, which is poor performance-wise because the CPU idles while the GPU renders causing everybody to wait on each other and generally slow things down. If we have multiple frames moving between the CPU and GPU at once, then this issue goes away. Except each frame is going to need its own command buffer and synchronization objects.</p><p>Which means everything is vectors now.</p><p>Joy.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=font-weight:700>pub</span> <span style=font-weight:700>struct</span> <span style=font-weight:700>VulkanDetails</span> {
</span></span><span style=display:flex><span>    entry: <span style=font-weight:700>ash</span>::Entry,
</span></span><span style=display:flex><span>    instance: <span style=font-weight:700>ash</span>::Instance,
</span></span><span style=display:flex><span>    debug_messenger: <span style=font-weight:700>vk</span>::DebugUtilsMessengerEXT,
</span></span><span style=display:flex><span>    surface: <span style=font-weight:700>vk</span>::SurfaceKHR,
</span></span><span style=display:flex><span>    physical_device: <span style=font-weight:700>vk</span>::PhysicalDevice,
</span></span><span style=display:flex><span>    device: <span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    graphics_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    present_queue: <span style=font-weight:700>vk</span>::Queue,
</span></span><span style=display:flex><span>    swap_chain: <span style=font-weight:700>vk</span>::SwapchainKHR,
</span></span><span style=display:flex><span>    swap_chain_images: Vec&lt;vk::Image&gt;,
</span></span><span style=display:flex><span>    swap_chain_image_format: <span style=font-weight:700>vk</span>::Format,
</span></span><span style=display:flex><span>    swap_chain_extent: <span style=font-weight:700>vk</span>::Extent2D,
</span></span><span style=display:flex><span>    swap_chain_image_views: Vec&lt;vk::ImageView&gt;,
</span></span><span style=display:flex><span>    render_pass: <span style=font-weight:700>vk</span>::RenderPass,
</span></span><span style=display:flex><span>    pipeline_layout: <span style=font-weight:700>vk</span>::PipelineLayout,
</span></span><span style=display:flex><span>    graphics_pipeline: <span style=font-weight:700>vk</span>::Pipeline,
</span></span><span style=display:flex><span>    swap_chain_framebuffers: Vec&lt;vk::Framebuffer&gt;,
</span></span><span style=display:flex><span>    command_pool: <span style=font-weight:700>vk</span>::CommandPool,
</span></span><span style=display:flex><span>    command_buffers: Vec&lt;vk::CommandBuffer&gt;,
</span></span><span style=display:flex><span>    image_available_semaphores: Vec&lt;vk::Semaphore&gt;,
</span></span><span style=display:flex><span>    render_finished_semaphores: Vec&lt;vk::Semaphore&gt;,
</span></span><span style=display:flex><span>    in_flight_fences: Vec&lt;vk::Fence&gt;,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Naturally this means changing our functions for creating all of these, too:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_command_buffers(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>        command_pool: <span>&amp;</span><span style=font-weight:700>vk</span>::CommandPool,
</span></span><span style=display:flex><span>    ) -&gt; Vec&lt;vk::CommandBuffer&gt; {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> alloc_info = vk::CommandBufferAllocateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::COMMAND_BUFFER_ALLOCATE_INFO,
</span></span><span style=display:flex><span>            command_pool: *command_pool,
</span></span><span style=display:flex><span>            level: <span style=font-weight:700>vk</span>::CommandBufferLevel::PRIMARY,
</span></span><span style=display:flex><span>            command_buffer_count: <span style=font-weight:700>MAX_FRAMES_IN_FLIGHT</span> <span style=font-weight:700>as</span> <span>u32</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { device.allocate_command_buffers(&amp;alloc_info).unwrap() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> create_sync_objects(
</span></span><span style=display:flex><span>        device: <span>&amp;</span><span style=font-weight:700>ash</span>::Device,
</span></span><span style=display:flex><span>    ) -&gt; (Vec&lt;vk::Semaphore&gt;, Vec&lt;vk::Semaphore&gt;, Vec&lt;vk::Fence&gt;) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> semaphore_info = vk::SemaphoreCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::SEMAPHORE_CREATE_INFO,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> fence_info = vk::FenceCreateInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::FENCE_CREATE_INFO,
</span></span><span style=display:flex><span>            flags: <span style=font-weight:700>vk</span>::FenceCreateFlags::SIGNALED,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> image_available_semaphores = Vec::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> render_finished_semaphores = Vec::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> <span style=font-weight:700>mut</span> in_flight_fences = Vec::new();
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> _ <span style=font-weight:700>in</span> 0..MAX_FRAMES_IN_FLIGHT {
</span></span><span style=display:flex><span>                image_available_semaphores
</span></span><span style=display:flex><span>                    .push(device.create_semaphore(&amp;semaphore_info, None).unwrap());
</span></span><span style=display:flex><span>                render_finished_semaphores
</span></span><span style=display:flex><span>                    .push(device.create_semaphore(&amp;semaphore_info, None).unwrap());
</span></span><span style=display:flex><span>                in_flight_fences.push(device.create_fence(&amp;fence_info, None).unwrap());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            image_available_semaphores,
</span></span><span style=display:flex><span>            render_finished_semaphores,
</span></span><span style=display:flex><span>            in_flight_fences,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And that means we also get to change our <code>draw_frame</code> and <code>record_command_buffer</code> functions:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> record_command_buffer(&amp;self, image_index: <span>usize</span>) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> begin_info = vk::CommandBufferBeginInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::COMMAND_BUFFER_BEGIN_INFO,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .begin_command_buffer(self.command_buffers[self.current_frame], &amp;begin_info)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> clear_color = vk::ClearValue {
</span></span><span style=display:flex><span>            color: <span style=font-weight:700>vk</span>::ClearColorValue {
</span></span><span style=display:flex><span>                float32: [0.0, 0.0, 0.0, 1.0],
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> render_pass_info = vk::RenderPassBeginInfo {
</span></span><span style=display:flex><span>            s_type: <span style=font-weight:700>vk</span>::StructureType::RENDER_PASS_BEGIN_INFO,
</span></span><span style=display:flex><span>            render_pass: <span style=font-weight:700>self</span>.render_pass,
</span></span><span style=display:flex><span>            framebuffer: <span style=font-weight:700>self</span>.swap_chain_framebuffers[image_index],
</span></span><span style=display:flex><span>            render_area: <span style=font-weight:700>vk</span>::Rect2D {
</span></span><span style=display:flex><span>                offset: <span style=font-weight:700>vk</span>::Offset2D { x: 0, y: 0 },
</span></span><span style=display:flex><span>                extent: <span style=font-weight:700>self</span>.swap_chain_extent,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            clear_value_count: 1,
</span></span><span style=display:flex><span>            p_clear_values: <span>&amp;</span><span style=font-weight:700>clear_color</span>,
</span></span><span style=display:flex><span>            ..Default::default()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device.cmd_begin_render_pass(
</span></span><span style=display:flex><span>                self.command_buffers[self.current_frame],
</span></span><span style=display:flex><span>                &amp;render_pass_info,
</span></span><span style=display:flex><span>                vk::SubpassContents::INLINE,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            self.device.cmd_bind_pipeline(
</span></span><span style=display:flex><span>                self.command_buffers[self.current_frame],
</span></span><span style=display:flex><span>                vk::PipelineBindPoint::GRAPHICS,
</span></span><span style=display:flex><span>                self.graphics_pipeline,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> viewport = vk::Viewport {
</span></span><span style=display:flex><span>            x: 0.0,
</span></span><span style=display:flex><span>            y: 0.0,
</span></span><span style=display:flex><span>            width: <span style=font-weight:700>self</span>.swap_chain_extent.width <span style=font-weight:700>as</span> <span>f32</span>,
</span></span><span style=display:flex><span>            height: <span style=font-weight:700>self</span>.swap_chain_extent.height <span style=font-weight:700>as</span> <span>f32</span>,
</span></span><span style=display:flex><span>            min_depth: 0.0,
</span></span><span style=display:flex><span>            max_depth: 1.0,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .cmd_set_viewport(self.command_buffers[self.current_frame], 0, &amp;[viewport]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> scissor = vk::Rect2D {
</span></span><span style=display:flex><span>            offset: <span style=font-weight:700>vk</span>::Offset2D { x: 0, y: 0 },
</span></span><span style=display:flex><span>            extent: <span style=font-weight:700>self</span>.swap_chain_extent,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .cmd_set_scissor(self.command_buffers[self.current_frame], 0, &amp;[scissor]);
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .cmd_draw(self.command_buffers[self.current_frame], 3, 1, 0, 0);
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .cmd_end_render_pass(self.command_buffers[self.current_frame]);
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .end_command_buffer(self.command_buffers[self.current_frame])
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> draw_frame(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .wait_for_fences(&amp;[self.in_flight_fences[self.current_frame]], <span style=font-weight:700>true</span>, <span>u64</span>::MAX)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .reset_fences(&amp;[self.in_flight_fences[self.current_frame]])
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> swap_chain_handle = Swapchain::new(&amp;self.instance, &amp;self.device);
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> (image_index, _) = swap_chain_handle
</span></span><span style=display:flex><span>                .acquire_next_image(
</span></span><span style=display:flex><span>                    self.swap_chain,
</span></span><span style=display:flex><span>                    <span>u64</span>::MAX,
</span></span><span style=display:flex><span>                    self.image_available_semaphores[self.current_frame],
</span></span><span style=display:flex><span>                    vk::Fence::null(),
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .reset_command_buffer(
</span></span><span style=display:flex><span>                    self.command_buffers[self.current_frame],
</span></span><span style=display:flex><span>                    vk::CommandBufferResetFlags::empty(),
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.record_command_buffer(image_index <span style=font-weight:700>as</span> <span>usize</span>);
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> submit_info = vk::SubmitInfo {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::SUBMIT_INFO,
</span></span><span style=display:flex><span>                wait_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_wait_semaphores: [self.image_available_semaphores[self.current_frame]].as_ptr(),
</span></span><span style=display:flex><span>                p_wait_dst_stage_mask: [vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT].as_ptr(),
</span></span><span style=display:flex><span>                command_buffer_count: 1,
</span></span><span style=display:flex><span>                p_command_buffers: [self.command_buffers[self.current_frame]].as_ptr(),
</span></span><span style=display:flex><span>                signal_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_signal_semaphores: [self.render_finished_semaphores[self.current_frame]].as_ptr(),
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .queue_submit(
</span></span><span style=display:flex><span>                    self.graphics_queue,
</span></span><span style=display:flex><span>                    &amp;[submit_info],
</span></span><span style=display:flex><span>                    self.in_flight_fences[self.current_frame],
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> present_info = vk::PresentInfoKHR {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::PRESENT_INFO_KHR,
</span></span><span style=display:flex><span>                wait_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_wait_semaphores: [self.render_finished_semaphores[self.current_frame]].as_ptr(),
</span></span><span style=display:flex><span>                swapchain_count: 1,
</span></span><span style=display:flex><span>                p_swapchains: [self.swap_chain].as_ptr(),
</span></span><span style=display:flex><span>                p_image_indices: <span>&amp;</span><span style=font-weight:700>image_index</span>,
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            swap_chain_handle
</span></span><span style=display:flex><span>                .queue_present(self.present_queue, &amp;present_info)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.current_frame = (self.current_frame + 1) % MAX_FRAMES_IN_FLIGHT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And yes, we take in <code>self</code> mutably for drawing a frame all because we need to update what frame we&rsquo;re drawing. Such as it is.</p><h2 id=recreating-the-swap-chain>Recreating the Swap Chain
<a class=heading-link href=#recreating-the-swap-chain><i class="fa fa-link" aria-hidden=true></i></a></h2><p>One last step: <a href=https://vulkan-tutorial.com/en/Drawing_a_triangle/Swap_chain_recreation>recreating the swap chain</a> every time we need to, which will be for window resizing, minimization, and whatnot. The basic function structure is&mldr; a bit more chunky than the C++:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> recreate_swap_chain(&amp;<span style=font-weight:700>mut</span> self, window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> { self.device.device_wait_idle().unwrap() };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.cleanup_swap_chain();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            self.swap_chain,
</span></span><span style=display:flex><span>            self.swap_chain_images,
</span></span><span style=display:flex><span>            self.swap_chain_image_format,
</span></span><span style=display:flex><span>            self.swap_chain_extent,
</span></span><span style=display:flex><span>        ) = VulkanDetails::create_swap_chain(
</span></span><span style=display:flex><span>            &amp;window,
</span></span><span style=display:flex><span>            &amp;self.entry,
</span></span><span style=display:flex><span>            &amp;self.instance,
</span></span><span style=display:flex><span>            &amp;self.physical_device,
</span></span><span style=display:flex><span>            &amp;self.device,
</span></span><span style=display:flex><span>            &amp;self.surface,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.swap_chain_image_views = VulkanDetails::create_image_views(
</span></span><span style=display:flex><span>            &amp;self.device,
</span></span><span style=display:flex><span>            &amp;self.swap_chain_images,
</span></span><span style=display:flex><span>            &amp;self.swap_chain_image_format,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.swap_chain_framebuffers = VulkanDetails::create_framebuffers(
</span></span><span style=display:flex><span>            &amp;self.device,
</span></span><span style=display:flex><span>            &amp;self.swap_chain_image_views,
</span></span><span style=display:flex><span>            &amp;self.swap_chain_extent,
</span></span><span style=display:flex><span>            &amp;self.render_pass,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Necessary since all of these functions were originally conceived without our struct being populated. The cleanup code for our swapchain is just our cleanup code, moved around:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup_swap_chain(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> framebuffer <span style=font-weight:700>in</span> &amp;self.swap_chain_framebuffers {
</span></span><span style=display:flex><span>                self.device.destroy_framebuffer(*framebuffer, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> image_view <span style=font-weight:700>in</span> &amp;self.swap_chain_image_views {
</span></span><span style=display:flex><span>                self.device.destroy_image_view(*image_view, None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Swapchain::new(&amp;self.instance, &amp;self.device).destroy_swapchain(self.swap_chain, None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>fn</span> cleanup(&amp;<span style=font-weight:700>mut</span> self) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.cleanup_swap_chain();
</span></span><span style=display:flex><span>            self.device.destroy_pipeline(self.graphics_pipeline, None);
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .destroy_pipeline_layout(self.pipeline_layout, None);
</span></span><span style=display:flex><span>            self.device.destroy_render_pass(self.render_pass, None);
</span></span><span style=display:flex><span>            <span style=font-weight:700>for</span> i <span style=font-weight:700>in</span> 0..MAX_FRAMES_IN_FLIGHT {
</span></span><span style=display:flex><span>                self.device
</span></span><span style=display:flex><span>                    .destroy_semaphore(self.image_available_semaphores[i], None);
</span></span><span style=display:flex><span>                self.device
</span></span><span style=display:flex><span>                    .destroy_semaphore(self.render_finished_semaphores[i], None);
</span></span><span style=display:flex><span>                self.device.destroy_fence(self.in_flight_fences[i], None);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            self.device.destroy_command_pool(self.command_pool, None);
</span></span><span style=display:flex><span>            self.device.destroy_device(None);
</span></span><span style=display:flex><span>            DebugUtils::new(&amp;self.entry, &amp;self.instance)
</span></span><span style=display:flex><span>                .destroy_debug_utils_messenger(self.debug_messenger, None);
</span></span><span style=display:flex><span>            Surface::new(&amp;self.entry, &amp;self.instance).destroy_surface(self.surface, None);
</span></span><span style=display:flex><span>            self.instance.destroy_instance(None);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Bake these into our <code>draw_frame</code> function, dealing with some of those results that we just casually unwrapped by actually doing something properly now:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> draw_frame(&amp;<span style=font-weight:700>mut</span> self, window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .wait_for_fences(&amp;[self.in_flight_fences[self.current_frame]], <span style=font-weight:700>true</span>, <span>u64</span>::MAX)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .reset_fences(&amp;[self.in_flight_fences[self.current_frame]])
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> swap_chain_handle = Swapchain::new(&amp;self.instance, &amp;self.device);
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> (image_index, _) = <span style=font-weight:700>match</span> swap_chain_handle.acquire_next_image(
</span></span><span style=display:flex><span>                self.swap_chain,
</span></span><span style=display:flex><span>                <span>u64</span>::MAX,
</span></span><span style=display:flex><span>                self.image_available_semaphores[self.current_frame],
</span></span><span style=display:flex><span>                vk::Fence::null(),
</span></span><span style=display:flex><span>            ) {
</span></span><span style=display:flex><span>                Ok(value) =&gt; value,
</span></span><span style=display:flex><span>                Err(error) =&gt; <span style=font-weight:700>match</span> error {
</span></span><span style=display:flex><span>                    vk::Result::ERROR_OUT_OF_DATE_KHR =&gt; {
</span></span><span style=display:flex><span>                        self.recreate_swap_chain(window);
</span></span><span style=display:flex><span>                        <span style=font-weight:700>return</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ =&gt; panic!(<span style=font-style:italic>&#34;Problem with the surface!&#34;</span>),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .reset_command_buffer(
</span></span><span style=display:flex><span>                    self.command_buffers[self.current_frame],
</span></span><span style=display:flex><span>                    vk::CommandBufferResetFlags::empty(),
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            self.record_command_buffer(image_index <span style=font-weight:700>as</span> <span>usize</span>);
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> submit_info = vk::SubmitInfo {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::SUBMIT_INFO,
</span></span><span style=display:flex><span>                wait_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_wait_semaphores: [self.image_available_semaphores[self.current_frame]].as_ptr(),
</span></span><span style=display:flex><span>                p_wait_dst_stage_mask: [vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT].as_ptr(),
</span></span><span style=display:flex><span>                command_buffer_count: 1,
</span></span><span style=display:flex><span>                p_command_buffers: [self.command_buffers[self.current_frame]].as_ptr(),
</span></span><span style=display:flex><span>                signal_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_signal_semaphores: [self.render_finished_semaphores[self.current_frame]].as_ptr(),
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .queue_submit(
</span></span><span style=display:flex><span>                    self.graphics_queue,
</span></span><span style=display:flex><span>                    &amp;[submit_info],
</span></span><span style=display:flex><span>                    self.in_flight_fences[self.current_frame],
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> present_info = vk::PresentInfoKHR {
</span></span><span style=display:flex><span>                s_type: <span style=font-weight:700>vk</span>::StructureType::PRESENT_INFO_KHR,
</span></span><span style=display:flex><span>                wait_semaphore_count: 1,
</span></span><span style=display:flex><span>                p_wait_semaphores: [self.render_finished_semaphores[self.current_frame]].as_ptr(),
</span></span><span style=display:flex><span>                swapchain_count: 1,
</span></span><span style=display:flex><span>                p_swapchains: [self.swap_chain].as_ptr(),
</span></span><span style=display:flex><span>                p_image_indices: <span>&amp;</span><span style=font-weight:700>image_index</span>,
</span></span><span style=display:flex><span>                ..Default::default()
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> swap_chain_handle.queue_present(self.present_queue, &amp;present_info) {
</span></span><span style=display:flex><span>                Ok(should_recreate) =&gt; {
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> should_recreate {
</span></span><span style=display:flex><span>                        self.recreate_swap_chain(window);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Err(error) =&gt; <span style=font-weight:700>match</span> error {
</span></span><span style=display:flex><span>                    vk::Result::ERROR_OUT_OF_DATE_KHR =&gt; self.recreate_swap_chain(window),
</span></span><span style=display:flex><span>                    _ =&gt; panic!(<span style=font-style:italic>&#34;Unable to present!&#34;</span>),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            self.current_frame = (self.current_frame + 1) % MAX_FRAMES_IN_FLIGHT;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Notably, if we ran it as things are now, it will deadlock. Not particularly convenient. This has to do with our current fence approach, which we should take care of real quick:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> draw_frame(&amp;<span style=font-weight:700>mut</span> self, window: <span>&amp;</span><span style=font-weight:700>winit</span>::window::Window) {
</span></span><span style=display:flex><span>        <span style=font-weight:700>unsafe</span> {
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .wait_for_fences(&amp;[self.in_flight_fences[self.current_frame]], <span style=font-weight:700>true</span>, <span>u64</span>::MAX)
</span></span><span style=display:flex><span>                .unwrap();
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> swap_chain_handle = Swapchain::new(&amp;self.instance, &amp;self.device);
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> (image_index, _) = <span style=font-weight:700>match</span> swap_chain_handle.acquire_next_image(
</span></span><span style=display:flex><span>                self.swap_chain,
</span></span><span style=display:flex><span>                <span>u64</span>::MAX,
</span></span><span style=display:flex><span>                self.image_available_semaphores[self.current_frame],
</span></span><span style=display:flex><span>                vk::Fence::null(),
</span></span><span style=display:flex><span>            ) {
</span></span><span style=display:flex><span>                Ok(value) =&gt; value,
</span></span><span style=display:flex><span>                Err(error) =&gt; <span style=font-weight:700>match</span> error {
</span></span><span style=display:flex><span>                    vk::Result::ERROR_OUT_OF_DATE_KHR =&gt; {
</span></span><span style=display:flex><span>                        self.recreate_swap_chain(window);
</span></span><span style=display:flex><span>                        <span style=font-weight:700>return</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    _ =&gt; panic!(<span style=font-style:italic>&#34;Problem with the surface!&#34;</span>),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>            self.device
</span></span><span style=display:flex><span>                .reset_fences(&amp;[self.in_flight_fences[self.current_frame]])
</span></span><span style=display:flex><span>                .unwrap();
</span></span></code></pre></div><p>Just don&rsquo;t reset the fence until we&rsquo;re past the point where we might return early. Easy peasy. Now we have to take care of resizing, since a resize triggering <code>VK_ERROR_OUT_OF_DATE_KHR</code> isn&rsquo;t guaranteed. So, we make a change in our checking for recreating the swap chain:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>            <span style=font-weight:700>match</span> swap_chain_handle.queue_present(self.present_queue, &amp;present_info) {
</span></span><span style=display:flex><span>                Ok(should_recreate) =&gt; {
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> should_recreate || self.framebuffer_resized {
</span></span><span style=display:flex><span>                        self.framebuffer_resized = <span style=font-weight:700>false</span>;
</span></span><span style=display:flex><span>                        self.recreate_swap_chain(window);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Err(error) =&gt; <span style=font-weight:700>match</span> error {
</span></span><span style=display:flex><span>                    vk::Result::ERROR_OUT_OF_DATE_KHR =&gt; self.recreate_swap_chain(window),
</span></span><span style=display:flex><span>                    _ =&gt; panic!(<span style=font-style:italic>&#34;Unable to present!&#34;</span>),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            };
</span></span></code></pre></div><p>And we upate our <code>run</code> function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(<span style=font-weight:700>mut</span> self) -&gt; ! {
</span></span><span style=display:flex><span>        self.event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Poll;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; *control_flow = ControlFlow::Exit,
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::Resized(_),
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; {
</span></span><span style=display:flex><span>                    self.vulkan_details.framebuffer_resized = <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Event::LoopDestroyed =&gt; {
</span></span><span style=display:flex><span>                    <span style=font-weight:700>unsafe</span> { self.vulkan_details.device.device_wait_idle().unwrap() };
</span></span><span style=display:flex><span>                    self.vulkan_details.cleanup();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _ =&gt; {
</span></span><span style=display:flex><span>                    self.vulkan_details.draw_frame(&amp;self.window);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now, all we have left is to pause whenever there&rsquo;s nothing to draw (such as minimizing or resizing to the point where the framebuffer is gone). However, there&rsquo;s a problem: we can&rsquo;t just stall until we get another event. This needs to be handled in the event loop, not our swap chain recreation. This is actually rather simple; we can just not draw when one of our size dimensions is zero:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>pub</span> <span style=font-weight:700>fn</span> run(<span style=font-weight:700>mut</span> self) -&gt; ! {
</span></span><span style=display:flex><span>        self.event_loop.run(<span style=font-weight:700>move</span> |event, _, control_flow| {
</span></span><span style=display:flex><span>            *control_flow = ControlFlow::Poll;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>match</span> event {
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::CloseRequested,
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; *control_flow = ControlFlow::Exit,
</span></span><span style=display:flex><span>                Event::WindowEvent {
</span></span><span style=display:flex><span>                    event: <span style=font-weight:700>WindowEvent</span>::Resized(size),
</span></span><span style=display:flex><span>                    window_id,
</span></span><span style=display:flex><span>                } <span style=font-weight:700>if</span> window_id == self.window.id() =&gt; {
</span></span><span style=display:flex><span>                    self.vulkan_details.framebuffer_resized = <span style=font-weight:700>true</span>;
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> size.width &gt; 0 &amp;&amp; size.height &gt; 0 {
</span></span><span style=display:flex><span>                        self.vulkan_details.draw_frame(&amp;self.window);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Event::LoopDestroyed =&gt; {
</span></span><span style=display:flex><span>                    <span style=font-weight:700>unsafe</span> { self.vulkan_details.device.device_wait_idle().unwrap() };
</span></span><span style=display:flex><span>                    self.vulkan_details.cleanup();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                _ =&gt; {
</span></span><span style=display:flex><span>                    <span style=font-weight:700>if</span> self.window.inner_size().width &gt; 0 &amp;&amp; self.window.inner_size().height &gt; 0 {
</span></span><span style=display:flex><span>                        self.vulkan_details.draw_frame(&amp;self.window);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>And there we are! We&rsquo;re drawing a triangle! It doesn&rsquo;t vomit errors at us if we minimize or resize things! The next steps will be quite a bit more complicated, but at least we can visually see the product of our effort now.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>Â©
2022
Brad Dragun (LuuBluum)
Â·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script></body></html>